File: C:\Documents and Settings\Matt\Desktop\walsh\suboptimal_decoder.v 
`timescale 1ns / 1ps 
1
2 
3  module suboptimal_decoder(reset, clk, num_fhts, symbol_in, bits_out,
ready, first_upper_corr_sum, first_lower_corr_sum, ctr,
first_big_corr_idx, first_big_corr_val, upper_corr, lower_corr, idx);
input reset, clk;
input [2:0] num_fhts;
parameter WIDTH=10;
input [WIDTH-1:0] symbol_in;
output [5:0] bits_out;
output ready;
output [15:0] first_upper_corr_sum, first_lower_corr_sum;
output [6:0] ctr;
output [2:0] first_big_corr_idx;
output [WIDTH-1:0] first_big_corr_val;
output [WIDTH-1:0] upper_corr, lower_corr;
output [5:0] idx;
wire [WIDTH-1:0] upper_corr, lower_corr; 
reg ready;
reg ready_thrown; 
wire [15:0] reset_fhts;
reg [WIDTH-1:0] symbols [63:0]; 
// Chagned
wire [15:0] fht_dones;
reg [WIDTH*16-1:0] upper_inputs, lower_inputs;
wire [WIDTH*16-1:0] upper_corrs, lower_corrs;
assign upper_corr = upper_corrs[9:0];
assign lower_corr = lower_corrs[9:0]; 

// 8 FHTs for first 3 bits, 8 FHTs for last 3 bits
fht_8_symbol fht[15:0](reset, clk, upper_inputs, lower_inputs,
upper_corrs, lower_corrs, fht_dones); 
wire [15:0] first_upper_corr_sum, first_lower_corr_sum,
last_upper_corr_sum, last_lower_corr_sum;
assign first_upper_corr_sum = upper_corrs[1*WIDTH-1:0*WIDTH]
 + upper_corrs[2*WIDTH-1:1*WIDTH]
 + upper_corrs[3*WIDTH-1:2*WIDTH]
 + upper_corrs[4*WIDTH-1:3*WIDTH]
 + upper_corrs[5*WIDTH-1:4*WIDTH]
 + upper_corrs[6*WIDTH-1:5*WIDTH]
 + upper_corrs[7*WIDTH-1:6*WIDTH]
 + upper_corrs[8*WIDTH-1:7*WIDTH];
assign first_lower_corr_sum = lower_corrs[1*WIDTH-1:0*WIDTH]
 + lower_corrs[2*WIDTH-1:1*WIDTH]
 + lower_corrs[3*WIDTH-1:2*WIDTH]
 + lower_corrs[4*WIDTH-1:3*WIDTH]
 + lower_corrs[5*WIDTH-1:4*WIDTH]
 + lower_corrs[6*WIDTH-1:5*WIDTH]
 + lower_corrs[7*WIDTH-1:6*WIDTH]
 + lower_corrs[8*WIDTH-1:7*WIDTH];

Page: 1 

4 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37
38
39
40
41
42
43
44 
45
46
47
48
49
50
51
52 

File: C:\Documents and Settings\Matt\Desktop\walsh\suboptimal_decoder.v 
assign last_upper_corr_sum = upper_corrs[9*WIDTH-1:8*WIDTH] 

53 
 + upper_corrs[10*WIDTH-1:9*WIDTH]
54

 + upper_corrs[11*WIDTH-1:10*WIDTH]
55

 + upper_corrs[12*WIDTH-1:11*WIDTH]
56

 + upper_corrs[13*WIDTH-1:12*WIDTH]
57

 + upper_corrs[14*WIDTH-1:13*WIDTH]
58

 + upper_corrs[15*WIDTH-1:14*WIDTH]
59

 + upper_corrs[16*WIDTH-1:15*WIDTH];
60

assign last_lower_corr_sum = lower_corrs[9*WIDTH-1:8*WIDTH] 

61 
 + lower_corrs[10*WIDTH-1:9*WIDTH] 

62
 + lower_corrs[11*WIDTH-1:10*WIDTH]

63
 + lower_corrs[12*WIDTH-1:11*WIDTH]

64
 + lower_corrs[13*WIDTH-1:12*WIDTH]

65
 + lower_corrs[14*WIDTH-1:13*WIDTH]

66
 + lower_corrs[15*WIDTH-1:14*WIDTH]

67
 + lower_corrs[16*WIDTH-1:15*WIDTH];

68
69

70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99
100
101 
102
103

reg [6:0] ctr;

integer i;

reg [2:0] first_big_corr_idx;

reg [WIDTH-1:0] first_big_corr_val;

reg [2:0] last_big_corr_idx;

reg [WIDTH-1:0] last_big_corr_val; 

wire [5:0] bits_out;

assign bits_out = ready ? {last_big_corr_idx[2:0], 

first_big_corr_idx[2:0]} : 6'b0;

always @(posedge clk) begin 

if (reset) begin

ctr <= 7'b0;

first_big_corr_idx <= 3'b0; 

first_big_corr_val <= 10'b0;

last_big_corr_idx <= 3'b0;

last_big_corr_val <= 10'b0; 

ready <= 0;

ready_thrown <= 0;

end else begin

// Cycles 0-63 -- buffer symbols coming in

symbols[ctr-1] <= symbol_in;

// Cycles 67-70 -- get output from FHTs

if (ctr <= 66) begin

first_big_corr_idx <= 3'b0; 

first_big_corr_val <= 10'b0;

last_big_corr_idx <= 3'b0;

last_big_corr_val <= 10'b0; 

end else begin

first_big_corr_idx <= first_upper_corr_sum > first_big_corr_val

&& first_upper_corr_sum > first_lower_corr_sum ? (ctr - 67) * 2 : 

(first_lower_corr_sum > first_big_corr_val) ? (ctr - 67) * 2
+ 1:
 first_big_corr_idx;
first_big_corr_val <= (first_upper_corr_sum > first_big_corr_val
&& first_upper_corr_sum > first_lower_corr_sum) ? first_upper_corr_sum :
(first_lower_corr_sum > first_big_corr_val) ? 

first_lower_corr_sum :

 first_big_corr_val;


Page: 2 

File: C:\Documents and Settings\Matt\Desktop\walsh\suboptimal_decoder.v 
last_big_corr_idx <= last_upper_corr_sum > last_big_corr_val &&
104 
last_upper_corr_sum > last_lower_corr_sum ? (ctr - 67) * 2 :
(last_lower_corr_sum > last_big_corr_val) ? (ctr - 67) * 2 +
105
1 :

 last_big_corr_idx;

106

last_big_corr_val <= (last_upper_corr_sum > last_big_corr_val &&
107

last_upper_corr_sum > last_lower_corr_sum) ? last_upper_corr_sum :
(last_lower_corr_sum > last_big_corr_val) ?
108
last_lower_corr_sum : 
 last_big_corr_val;
109
 end 
110
if (ctr > 69) begin
111 
ctr <= 0;
112 
if (!ready_thrown) begin
113 
ready <= 1;
114 
end 
115 
ready_thrown <= 1;
116 
end else begin
117 
ready <= 0;
118 
ctr <= ctr + 1;
119 
end 
120 
end 
121 
end 
122 
reg [5:0] idx;
123 
always @(ctr) begin
124 
125 
// Cycles 64-67 -- feed FHTs input
126 
if (ctr > 63 && ctr < 68) begin
127 
// First three bits' inputs
128 
idx = 0+8*(ctr-64);
129 
upper_inputs[WIDTH*(0+1)-1:WIDTH*0] = symbols[0+8*(ctr-64)];
130 
lower_inputs[WIDTH*(0+1)-1:WIDTH*0] = symbols[0+8*(ctr-64)+32];
131 
upper_inputs[WIDTH*(1+1)-1:WIDTH*1] = symbols[1+8*(ctr-64)];
132 
lower_inputs[WIDTH*(1+1)-1:WIDTH*1] = symbols[1+8*(ctr-64)+32];
133 
upper_inputs[WIDTH*(2+1)-1:WIDTH*2] = symbols[2+8*(ctr-64)];
134 
lower_inputs[WIDTH*(2+1)-1:WIDTH*2] = symbols[2+8*(ctr-64)+32];
135 
upper_inputs[WIDTH*(3+1)-1:WIDTH*3] = symbols[3+8*(ctr-64)];
136 
lower_inputs[WIDTH*(3+1)-1:WIDTH*3] = symbols[3+8*(ctr-64)+32];
137 
upper_inputs[WIDTH*(4+1)-1:WIDTH*4] = symbols[4+8*(ctr-64)];
138 
lower_inputs[WIDTH*(4+1)-1:WIDTH*4] = symbols[4+8*(ctr-64)+32];
139 
upper_inputs[WIDTH*(5+1)-1:WIDTH*5] = symbols[5+8*(ctr-64)];
140 
lower_inputs[WIDTH*(5+1)-1:WIDTH*5] = symbols[5+8*(ctr-64)+32];
141 
upper_inputs[WIDTH*(6+1)-1:WIDTH*6] = symbols[6+8*(ctr-64)];
142 
lower_inputs[WIDTH*(6+1)-1:WIDTH*6] = symbols[6+8*(ctr-64)+32];
143 
upper_inputs[WIDTH*(7+1)-1:WIDTH*7] = symbols[7+8*(ctr-64)];
144 
lower_inputs[WIDTH*(7+1)-1:WIDTH*7] = symbols[7+8*(ctr-64)+32];
145 
// Second three bits
146 
upper_inputs[WIDTH*(0+9)-1:WIDTH*8] = symbols[(0*8)+(ctr-64)];
147 
lower_inputs[WIDTH*(0+9)-1:WIDTH*8] = symbols[(0*8)+(ctr-64)+4];
148 
upper_inputs[WIDTH*(1+9)-1:WIDTH*9] = symbols[(1*8)+(ctr-64)];
149 
lower_inputs[WIDTH*(1+9)-1:WIDTH*9] = symbols[(1*8)+(ctr-64)+4];
150 
upper_inputs[WIDTH*(2+9)-1:WIDTH*10] = symbols[(2*8)+(ctr-64)];
151 
lower_inputs[WIDTH*(2+9)-1:WIDTH*10] =
152 
symbols[(2*8)+(ctr-64)+4];
upper_inputs[WIDTH*(3+9)-1:WIDTH*11] = symbols[(3*8)+(ctr-64)];
153 
lower_inputs[WIDTH*(3+9)-1:WIDTH*11] = 
154 

Page: 3 

File: C:\Documents and Settings\Matt\Desktop\walsh\suboptimal_decoder.v 
symbols[(3*8)+(ctr-64)+4];
154
upper_inputs[WIDTH*(4+9)-1:WIDTH*12] = symbols[(4*8)+(ctr-64)];
155 
lower_inputs[WIDTH*(4+9)-1:WIDTH*12] =
156 
symbols[(4*8)+(ctr-64)+4];
upper_inputs[WIDTH*(5+9)-1:WIDTH*13] = symbols[(5*8)+(ctr-64)];
157 
lower_inputs[WIDTH*(5+9)-1:WIDTH*13] =
158 
symbols[(5*8)+(ctr-64)+4];
upper_inputs[WIDTH*(6+9)-1:WIDTH*14] = symbols[(6*8)+(ctr-64)];
159 
lower_inputs[WIDTH*(6+9)-1:WIDTH*14] = 

160 
symbols[(6*8)+(ctr-64)+4]; 

upper_inputs[WIDTH*(7+9)-1:WIDTH*15] = symbols[(7*8)+(ctr-64)];
161 
lower_inputs[WIDTH*(7+9)-1:WIDTH*15] =
162 
symbols[(7*8)+(ctr-64)+4];
end 

163 
end

164 
165  endmodule


Page: 4 

16:32:33 05/03/06 

VerticalLine


File: C:\Documents and Settings\Matt\Desktop\walsh\vertical_line.v 
`timescale 1ns / 1ps
1
////////////////////////////////////////////////////////////////////////
2 
////////
// Company:
3
// Engineer:
4
//
5
// Create Date: 
6 
// Design Name:
7
// Module Name: 

8 
9  // Project Name:
// Target Device:
10
// Tool versions:
11
// Description:
12
//
13
// Dependencies:
14
//
15
// Revision:
16
// Revision 0.01 - File Created
17
// Additional Comments:
18
//
19
////////////////////////////////////////////////////////////////////////
20
////////
module vertical_line(start_y, end_y, x, pixel, line, color);

21
input [9:0] start_y, end_y, x; 

22 
input [9:0] pixel, line; 
23 
24 
output [23:0] color; 
25 
26 
reg [23:0] color; 
27 
28 
parameter WHITE = 24'hFFFFFF;
29 
parameter BLACK = 24'h0; 
30 
31 
always @(pixel or line or start_y or end_y or x) begin
32 
if (line >= start_y && line <= end_y && pixel == x) begin
33 
color = WHITE;
34 
end else begin
35 
color = BLACK;
36 
end 
37 
end 
38 
39  endmodule 

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\vga.v 
`timescale 1ns / 1ps
1
module vga (pixel_clock, reset, hsync, vsync, sync_b, blank_b,
2 
pixel_count, line_count);
input pixel_clock; // 31.5 MHz pixel clock
3 
input reset; // system reset

4 
output hsync; // horizontal sync

5

output vsync; // vertical sync 

6

output sync_b; // hardwired to Vdd 

7

output blank_b; // composite blank
8

output [9:0] pixel_count; // number of the current pixel
9 
output [9:0] line_count; // number of the current line
10 
// 640x480 75Hz parameters
11 
parameter PIXELS = 800;
12 
parameter LINES = 525;
13 
parameter HACTIVE_VIDEO = 640;
14 
parameter HFRONT_PORCH = 16;
15 
parameter HSYNC_PERIOD = 96;
16 
parameter HBACK_PORCH = 48;
17 
parameter VACTIVE_VIDEO = 480;
18 
parameter VFRONT_PORCH = 11;
19 
parameter VSYNC_PERIOD = 2;
20 
parameter VBACK_PORCH = 32;
21 
// current pixel count
22 
reg [9:0] pixel_count = 10'b0;
23 
reg [9:0] line_count = 10'b0;
24 
// registered outputs
25 
reg hsync = 1'b1;
26 
reg vsync = 1'b1;
27 
reg blank_b = 1'b1;
28 
wire sync_b; // connected to Vdd
29 
wire pixel_clock;
30 
wire [9:0] next_pixel_count;
31 
wire [9:0] next_line_count;
32 
always @ (posedge pixel_clock) begin
33 
if (reset) begin
34 
pixel_count <= 10'b0;
35 
line_count <= 10'b0;
36 
hsync <= 1'b1;
37 
vsync <= 1'b1;
38 
blank_b <= 1'b1;
39 
end else  begin
40 
pixel_count <= next_pixel_count;
41 
line_count <= next_line_count;
42 
hsync <=
43 
(next_pixel_count < HACTIVE_VIDEO + HFRONT_PORCH) |
44 
(next_pixel_count >= HACTIVE_VIDEO+HFRONT_PORCH+
45 
HSYNC_PERIOD);
46 
vsync <=
47 
(next_line_count < VACTIVE_VIDEO+VFRONT_PORCH) |
48 
(next_line_count >= VACTIVE_VIDEO+VFRONT_PORCH+
49 
VSYNC_PERIOD);
50 
// this is the and of hblank and vblank
51 
blank_b <= 
52 
(next_pixel_count < HACTIVE_VIDEO) &
53 
(next_line_count < VACTIVE_VIDEO);
54 
55 

end 

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\vga.v 
end 
56 
57 
// next state is computed with combinational logic
58 
assign next_pixel_count = (pixel_count == PIXELS-1) ?
59 
10'h000 : pixel_count + 1'b1;
60 
assign next_line_count = (pixel_count == PIXELS-1) ?
61 
(line_count == LINES-1) ? 10'h000 :
62 
line_count + 1'b1 : line_count;
63 
// since we are providing hsync and vsync to the display, we
64 
// can hardwire composite sync to Vdd.
65 
assign sync_b = 1'b1;
66 
67  endmodule 

Page: 2 

File: C:\Documents and Settings\Matt\Desktop\walsh\walsh.v 
`timescale 1ns / 1ps 
1
2 
3  module walsh(reset, clk, enable, num_fhts, optimal, symbols,
decoded_bits);
input clk, enable;
4 
input [2:0] num_fhts;
5 
input optimal;
6 
input [63:0] symbols; 
7 
8 
output [5:0] decoded_bits;
9 
reg [5:0] decoded_bits; 
10 
11 
parameter WIDTH = 10;
12 
wire [WIDTH-1:0] confidence; 
13 
14 
reg upper_input;
15 
reg lower_input;
16 
wire ready;
17 
fht_64_symbol optimal_decoder(reset, clk, upper_input, lower_input,
18 
decoded_bits, confidence, ready); 
19 
always @(posedge pixel_clock) begin
20 
if (enable) begin
21 
if 
22 
end 
23 
end 
24 
25  endmodule 

Page: 1 

1)  manual_reset:

a)  when low, systems runs as initialized from power up

b)  when high, system reloads control words 

2)  disp_test:

a)  when low, system loads dots (module input) into dot data

b)  when high, system loads 640 1's into dot data register 
3)  disp_blank:

a) always configured low for zero blanking

4)  disp_clock:

a)  set at 1/54th global_clock speed ( .5Mhz for 27Mhz input


File: C:\Documents and Settings\Matt\Desktop\walsh\alpha_display.v 
1  ////////////////////////////////////////////////////////////////////////
///////
//
2
// 6.111 FPGA Labkit -- Alphanumeric Display Interface for Lab 3 Memory
3 
Tester 
//
4
//
5
// Created: November 5, 2003
6
// Author: Nathan Ickes
7
//  Updated by Chris Buenrostro - 5/01/2006
8
//  Updated by Mike Scharfstein - 1/30/2006
9 
//
10
// 
Notes: 
11
//
12
// 
*** Code written for Agilent Technologies HCMS-2973 Alphanumeric
13 
Displays
//
14
// 
15 
16  // 
17  // 
//
18
// 
19 
20  // 
register
//

21 
//
22
// 
23 
24  // 
//
25
// 
26 
27  // 
clock)
//
28
5)  control_reg_value (parameter): 
//

29 
a)  controls brightness of LED banks (four banks) 
30  // 
1)  values for desired brightness can be found in datasheet
31  // 
//
32
////////////////////////////////////////////////////////////////////////
33 
/////// 
34 
module alpha_display
35
( 
36
global_clock, manual_reset, disp_test,

37 
disp_blank, disp_clock, disp_rs, disp_ce_b, disp_reset_b,

38 
disp_data_out,

dots

39 
);

40
41 
42
43 
44
45
46
47
48
49

// serial data to displays 

// register select 

// chip enable 

// display reset 


 input 
input  
 output 
 output 
 output 
 output 
 output 
 output 

global_clock;

manual_reset;

disp_blank;

disp_clock;

disp_data_out; 
disp_rs; 
disp_ce_b; 
disp_reset_b; 

Page: 1 

 

File: C:\Documents and Settings\Matt\Desktop\walsh\alpha_display.v 
50    input  [639:0] 
dots;
disp_test; 
input 
// check functionality of display
51 
52 
disp_blank = 1'b0;  // 0=not blanked 
 assign 
53
54 
 reg 
disp_clock;
55
disp_data_out;
reg 
56 
reg
disp_rs;
57 
reg 
disp_ce_b;
58 
disp_reset_b;
reg 
59 
 // Internal signals
60
 reg 
[5:0] 
count;
61
 reg 
[7:0] 
state;
62
 reg 
dot_index;
[9:0] 
63
 reg 
[639:0] 
ldots;
64
///////////////////////////////////
65 
//
66 
//  There are four Control Words 
67 
//
68 
///////////////////////////////////
69 
//  parameter 
control_reg_load_length = 8;  //first four Banks 
70 
//  parameter 
control_reg_load_length = 16; //second four Banks 
71 
//  parameter 
control_reg_load_length = 24; //third four Banks 
72 
parameter 
//all four Banks
control_reg_load_length = 32; 
73 
[control_reg_load_length - 1:0] control;
 reg 
74
75 
parameter RESET 
= 0; 
76 
parameter END_RESET 
= 1; 
77 
parameter INIT_DOT_REG 
= 2; 
78 
parameter LATCH_INIT_DOT_DATA = 3; 
79 
parameter SELECT_CONTROL_REG  = 4; 
80 
parameter SET_CONTROL_REG 
= 5; 
81 
parameter LATCH_CONTROL_REG 
= 6; 
82 
= 7; 
parameter SELECT_DOT_REG 
83 
= 8; 
parameter FILL_DOT_REG 
84 
parameter LATCH_DOT_DATA 
= 9; 
85 
parameter LOAD_NEW_DOT_DATA 
= 10; 
86 
87 
parameter control_reg_value 
=  32'h7F7F7F7F;  // Controls LED 
88 
brightness 
89 
90 

////////////////////////////////////////////////////////////////////////
////
//

 // Initial Reset Generation

//

*** SRL16 is a variable-width shift register 

// 
 //

////////////////////////////////////////////////////////////////////////
//// 
 wire reset;

 SRL16 reset_sr (.D(1'b0), .CLK(global_clock), .Q(reset), 


91
92
93 
94 
95
96


97 
98
99

100

Page: 2 

File: C:\Documents and Settings\Matt\Desktop\walsh\alpha_display.v 
 .A0(1'b1), .A1(1'b1), .A2(1'b1), .A3(1'b1));

101
 defparam reset_sr.INIT = 16'hFFFF;

102
103

104


////////////////////////////////////////////////////////////////////////
////
//

 // Sequential Logic Block

 //

////////////////////////////////////////////////////////////////////////
//// 
 always @(posedge global_clock)

begin 

if (reset || manual_reset) 

begin
count 
<= 0; 
<= 0; 
disp_clock 
<= 0; 
disp_data_out 
disp_rs 
<= 0; 
disp_ce_b 
<= 1; 
disp_reset_b  <= 0; 
<= 0; 
dot_index 
state 
<= 0; 
control 
<= control_reg_value; 
end 
else if (count==26)
begin
<= count+1; 
count 
disp_clock 
<= 1;
end 
else if (count==53)
begin
<= 0; 
count 
disp_clock 
<= 0; 

105
106
107
108


109 
110
111 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
122 
123 
124 
125 
126
127 
128 
129 
130 
131
132 
133 
134 

135
136
137
138 

139 
140 
141

142 
143 
144 
145 
146 
147 
148 

////////////////////////////////////////////////////////////////////////
//// 
//
 // Display State Machine
 //
////////////////////////////////////////////////////////////////////////
//// 

casex (state)

RESET:

begin 

disp_data_out 
disp_rs 
disp_ce_b 
disp_reset_b 
dot_index 

<= 1'b0; 
<= 1'b0; // dot register

<= 1'b1;

<= 1'b0; 

<= 0;


Page: 3 



 
 

 

<= 1'b1;

<= INIT_DOT_REG;


File: C:\Documents and Settings\Matt\Desktop\walsh\alpha_display.v 
state 
<= END_RESET; 

149 
 end  

150
 END_RESET: 

151
 begin

152
disp_reset_b 
153

state 
154

 end 

155
 INIT_DOT_REG: 
156

 begin
157
<= 1'b0; 
disp_ce_b 
158 
disp_data_out 
<= 1'b0; 
159
160 
if (dot_index == 0)
161 
<= LATCH_INIT_DOT_DATA;
state 
162 
else 
163 
dot_index 
<= dot_index-1; 
 
164
end 
165 
 LATCH_INIT_DOT_DATA: 
166
 begin
167
<= 1'b1; 
disp_ce_b 
168 
dot_index 
<= control_reg_load_length-1; 
 
169
state 
<= SELECT_CONTROL_REG; 
 
170
 end 
171
SELECT_CONTROL_REG: 
172 
begin
173 
<= 1'b1; 
 
disp_rs 
174
<= SET_CONTROL_REG; 
state 
175 
end 
176 
 SET_CONTROL_REG: 
177
 begin
178
disp_ce_b <= 1'b0;
179 
disp_data_out 
<= control[dot_index]; 
180 
181 
if (dot_index == 0)
182 
state 
<= LATCH_CONTROL_REG;
183 
else 
184 
dot_index 
<= dot_index-1;
185 
 end 
186
 LATCH_CONTROL_REG: 
187
 begin
188
disp_ce_b 
<= 1'b1; 
 
189
dot_index 
<= 639; 
 
190
 
state 
<= SELECT_DOT_REG; 
191
 end 
192
SELECT_DOT_REG: 
193 
begin
194 
disp_rs 
195 
state 
196 
end 
197 
 FILL_DOT_REG: 
198
 begin
199
disp_ce_b 
200 
201 
if (disp_test)
202 
disp_data_out 
203 
else 
204 

<= 1'b0; 
<= FILL_DOT_REG;

<= 1'b0; 

<= 1'b1; 

Page: 4 

File: C:\Documents and Settings\Matt\Desktop\walsh\alpha_display.v 
<= ldots[dot_index]; 

disp_data_out 
205 
206

if (dot_index == 0)

207

state 
<= LATCH_DOT_DATA; 

208

else 

209 
 
<= dot_index-1; 

dot_index 
210

end

211 
 LATCH_DOT_DATA:

212

 begin

213
<= 1'b1;

disp_ce_b 
214 
dot_index 
<= 639;

 
215
<= LOAD_NEW_DOT_DATA;

state 
 
216
 end 

217
 LOAD_NEW_DOT_DATA:

218
 begin
219
ldots 
<= dots; 
220 
<= FILL_DOT_REG; 
state 
221
end 
222
<= state; 
state 
default: 
223 
endcase 
224 
end 
225 
else 
226 
 count <= count+1;

227
end

228 
229  endmodule


Page: 5 

File: C:\Documents and Settings\Matt\Desktop\walsh\alpha_dots.v 
1  ////////////////////////////////////////////////////////////////////////
////////
//
2
// Lab 3 Memory Tester: Number to bitmap decoder
3
//
4
// This module converts a 4-bit input to a 80-dot (2 digit) bitmap
5 
representing
// the numbers ' 0' through '15'.
6
//
7
// Author: Yun Wu, Nathan Ickes
8
// Date: March 8, 2006
9 
//
10
////////////////////////////////////////////////////////////////////////
11
//////// 
12 
module alpha_dots(clk, num, dots);
13
input clk;
14
 input [3:0] num;
15
 output [79:0] dots;
16
17 
 reg [79:0] dots;
18
 always @ (posedge clk)
19
 case (num)
20
 4'd15: dots <= {40'b00000000_01000010_01111111_01000000_00000000,
21
// '15' 
40'b00100111_01000101_01000101_01000101_00111001};
22
 4'd14: dots <= {40'b00000000_01000010_01111111_01000000_00000000,
23
// '14' 
40'b00011000_00010100_00010010_01111111_00010000};
24
 4'd13: dots <= {40'b00000000_01000010_01111111_01000000_00000000,
25
// '13' 
40'b00100010_01000001_01001001_01001001_00110110};
26
 4'd12: dots <= {40'b00000000_01000010_01111111_01000000_00000000,
27
// '12' 
40'b01100010_01010001_01001001_01001001_01000110};
28
 4'd11: dots <= {40'b00000000_01000010_01111111_01000000_00000000,
29
// '11' 
40'b00000000_01000010_01111111_01000000_00000000};
30
 4'd10: dots <= {40'b00000000_01000010_01111111_01000000_00000000,
31
// '10' 
40'b00111110_01010001_01001001_01000101_00111110};
32
 4'd09: dots <= {40'b00000000_00000000_00000000_00000000_00000000,
33
// ' 9' 
40'b00000110_01001001_01001001_00101001_00011110};
34
 4'd08: dots <= {40'b00000000_00000000_00000000_00000000_00000000,
35
// ' 8' 
40'b00110110_01001001_01001001_01001001_00110110};
36
 4'd07: dots <= {40'b00000000_00000000_00000000_00000000_00000000,
37
// ' 7' 
40'b00000001_01110001_00001001_00000101_00000011};
38
4'd06: dots <= {40'b00000000_00000000_00000000_00000000_00000000,
39
// ' 6'
 40'b00111100_01001010_01001001_01001001_00110000};
40
 4'd05: dots <= {40'b00000000_00000000_00000000_00000000_00000000,
41
// ' 5' 
40'b00100111_01000101_01000101_01000101_00111001}; 
42

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\alpha_dots.v 
 4'd04: dots <= {40'b00000000_00000000_00000000_00000000_00000000,
43
// ' 4' 
40'b00011000_00010100_00010010_01111111_00010000};
44
 4'd03: dots <= {40'b00000000_00000000_00000000_00000000_00000000,
45
// ' 3' 
40'b00100010_01000001_01001001_01001001_00110110};
46
 4'd02: dots <= {40'b00000000_00000000_00000000_00000000_00000000,
47
// ' 2' 
40'b01100010_01010001_01001001_01001001_01000110}; 

48
 4'd01: dots <= {40'b00000000_00000000_00000000_00000000_00000000,

49
// ' 1' 
40'b00000000_01000010_01111111_01000000_00000000}; 

50
 4'd00: dots <= {40'b00000000_00000000_00000000_00000000_00000000,

51
// ' 0' 
40'b00111110_01010001_01001001_01000101_00111110}; 

52
 // No default case, becase every case is already accounted for.

53
 endcase

54
55

56  endmodule


Page: 2 

File: C:\Documents and Settings\Matt\Desktop\walsh\ber.v 
`timescale 1ns / 1ps 
1
2 
module ber(first_input, second_input, error_count);
3
// Combinational, parallel detection of mismatched bits
4 
input [5:0] first_input, second_input; 
5 
6 
output [2:0] error_count;
7 
wire [5:0] a, b; 
8 
9 
parameter WIDTH = 10; 
10 
11 
assign a = first_input;
12 
assign b = second_input;
13 
assign error_count = (a[0] ^ b[0]) + (a[1] ^ b[1]) + (a[2] ^ b[2]) +
14 
(a[3] ^ b[3]) + 
(a[4] ^ b[4]) + (a[5] ^ b[5]); // + (a[6] ^ b[6]) + 
15 
(a[7] ^ b[7]) + 
/*(a[8] ^ b[8]) + (a[9] ^ b[9]) + (a[10] ^ b[10]) +
16 
(a[11] ^ b[12]) +
(a[12] ^ b[12]) + (a[13] ^ b[13]) + (a[14] ^ b[14]) +
17 
(a[15] ^ b[15]) +
(a[16] ^ b[16]) + (a[17] ^ b[17]) + (a[18] ^ b[18]) +
18 
(a[19] ^ b[19]) +
(a[20] ^ b[20]) + (a[21] ^ b[21]) + (a[22] ^ b[22]) +
19 
(a[23] ^ b[23]) +
(a[24] ^ b[24]) + (a[25] ^ b[25]) + (a[26] ^ b[26]) +
20 
(a[27] ^ b[27]) +
(a[28] ^ b[28]) + (a[29] ^ b[29]) + (a[30] ^ b[30]) +
21 
(a[31] ^ b[31]) +
(a[32] ^ b[32]) + (a[33] ^ b[33]) + (a[34] ^ b[34]) +
22 
(a[35] ^ b[35]) +
(a[36] ^ b[36]) + (a[37] ^ b[37]) + (a[38] ^ b[38]) +
23 
(a[39] ^ b[39]) +
(a[40] ^ b[40]) + (a[41] ^ b[41]) + (a[42] ^ b[42]) +
24 
(a[43] ^ b[43]) +
(a[44] ^ b[44]) + (a[45] ^ b[45]) + (a[46] ^ b[46]) +
25 
(a[47] ^ b[47]) +
(a[48] ^ b[48]) + (a[49] ^ b[49]) + (a[50] ^ b[50]) +
26 
(a[51] ^ b[51]) +
(a[52] ^ b[52]) + (a[53] ^ b[53]) + (a[54] ^ b[54]) +
27 
(a[55] ^ b[55]) +
(a[56] ^ b[56]) + (a[57] ^ b[57]) + (a[58] ^ b[58]) +
28 
(a[59] ^ b[59]);
*/
29 
30  endmodule 

Page: 1 

22:41:05 05/10/06 

control


File: C:\Documents and Settings\Matt\Desktop\walsh\control.v 
`timescale 1ns / 1ps
1
////////////////////////////////////////////////////////////////////////
2 
////////
// Company:
3
// Engineer:
4
//
5
// Create Date: 
6 
// Design Name:
7
// Module Name: 

8 
9  // Project Name:
// Target Device:
10
// Tool versions:
11
// Description:
12
//
13
// Dependencies:
14
//
15
// Revision:
16
// Revision 0.01 - File Created
17
// Additional Comments:
18
//
19
////////////////////////////////////////////////////////////////////////
20
////////
module control(clk, reset, up, down, addr);

21
input clk, reset, up, down; 

22 
output [5:0] addr; 
23 
24 
25 
reg [5:0] ctr;
26 
wire [5:0] addr;
27 
assign addr = ctr; 
28 
29 
always @(posedge clk) begin
30 
if (reset) begin
31 
ctr <= 0;
32 
end else begin
33 
ctr <= ctr + 1;
34 
end 
35 
end 
36 
37  endmodule 

Page: 1 

- video pixel value to display at current location 

- video pixel clock
- horizontal (x) location of current pixel
- vertical (y) location of current pixel
- character string to display (8 bit ASCII for each
- pixel location (upper left corner) to display string


File: C:\Documents and Settings\Matt\Desktop\walsh\cstringdisp.v 
//
1
cstringdisp.v

// File: 
2 
24-Oct-05

3  // Date: 
4  // Author: I. Chuang, C. Terman

//
5
// Display an ASCII encoded character string in a video window at some
6
// specified x,y pixel location.
7
//
8
// INPUTS:
9 
//
10
vclock 
// 
11 
12  // 
hcount 
13  // 
vcount 
cstring 
14  // 
char)

// 
cx,cy 
15
at

//
16
// OUTPUT:
17
//
18
// 
pixel 
19 
//
20
// PARAMETERS:
21
//
22
// 
- number of characters in string to display
NCHAR 
23 
- number of bits to specify NCHAR 
24  // 
NCHAR_BITS 
//
25
// pixel should be OR'ed (or XOR'ed) to your video data for display.
26
//
27
// Each character is 8x12, but pixels are doubled horizontally and
28 
vertically
// so fonts are magnified 2x.  On an XGA screen (1024x768) you can fit 
29 
// 64 x 32 such characters.
30
//
31
// Needs font_rom.v and font_rom.ngo
32
//
33
// For different fonts, you can change font_rom.  For different string 
34 
// display colors, change the assignment to cpixel. 
35
36 
37 
38  ////////////////////////////////////////////////////////////////////////
//////
//
39 
// video character string display
40
//
41
////////////////////////////////////////////////////////////////////////
42 
////// 
43 
44  module char_string_display (vclock,hcount,vcount,pixel,cstring,cx,cy); 
45
46    parameter NCHAR = 11;  // number of 8-bit characters in cstring 
 parameter NCHAR_BITS = 5; // number of bits in NCHAR
47
parameter SCALE = 1;
48 
49
   input vclock;  // 65MHz clock 
50
51    input [10:0] hcount; // horizontal index of current pixel (0..1023) 

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\cstringdisp.v 
52    input [9:0]  vcount; // vertical index of current pixel (0..767) 
53    output [2:0] pixel;  // char display's pixel

54
    input [NCHAR*8-1:0] cstring; // character string to display 

 input [10:0] cx;

55

56
    input [9:0]  cy;

57

 // 1 line x 8 character display (8 x 12 pixel-sized characters)
58

59 
60    wire [10:0]  hoff = (hcount-1-cx) * SCALE; 
 wire [9:0] 
voff = (vcount-cy)*SCALE;
61
 wire [NCHAR_BITS-1:0] column = NCHAR-1-hoff[NCHAR_BITS-1+4:4];  // <
62
NCHAR 
 wire [2:0] 
h = hoff[3:1]; 
// 0 .. 7
63
 wire [3:0] 
 // 0 .. 11
v = voff[4:1];
64
65 
 // look up character to display (from character string)
66
 reg [7:0]  char;
67
 integer  n;
68
 always @( * )
69
 for (n=0 ; n<8 ; n = n+1 )  // 8 bits per character (ASCII)
70
 char[n] <= cstring[column*8+n];
71
72 
 // look up raster row from font rom
73
 wire reverse = char[7];
74
 wire [10:0] font_addr = char[6:0]*12 + v; 
75
character

 wire [7:0]  font_byte;

76
 font_rom f(font_addr,vclock,font_byte);

77
78

 // generate character pixel if we're in the right h,v area 

79
 wire [2:0] cpixel = (font_byte[7 - h] ^ reverse) ? 7 : 0;

80
 wire dispflag = ((hcount > cx) & (vcount >= cy) & (hcount <=

81
cx+NCHAR*((SCALE == 1) ? 16 : 8))

& (vcount < cy + ((SCALE == 1) ? 24 : 12)));

82
 wire [2:0] pixel = dispflag ? cpixel : 0; 

83
84

85  endmodule


// 12 bytes per

Page: 2 

File: C:\Documents and Settings\Matt\Desktop\walsh\debounce.v 
// Switch Debounce Module

1
// use your system clock for the clock input 

2
// to produce a synchronous, debounced output

3
module debounce (reset, clock, noisy, clean);

4
parameter DELAY = 270000; 
// .01 sec with a 27Mhz clock 

5
input reset, clock, noisy; 

6
output clean;

7
8
 reg [18:0] count;

9
reg new, clean;

10
11
 always @(posedge clock) 

12
if (reset)

13
begin 

14
count <= 0;

15
new <= noisy;

16
clean <= noisy;

17
end

18
 else if (noisy != new)

19
begin 

20
new <= noisy;

21
count <= 0;

22
end

23
 else if (count == DELAY)

24
clean <= new;

25
else

26
 count <= count+1;

27
28
endmodule 
29

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\display.v 
`timescale 1ns / 1ps 
1
2 
3  module display(got_new_data, clock, reset, enable, pixel, line, color,
current_error_count, power_usage, new_data_count, error_count);
input clock, enable, reset, got_new_data;
4 
input [9:0] pixel, line;
5 
input [2:0] current_error_count;
6 
input [2:0] power_usage;
7 
output [7:0] new_data_count, error_count;
8 
output [23:0] color; 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 

parameter WIDTH = 640;
parameter HEIGHT = 480;
parameter MIT_RED = 24'b0101_1111_0001_1111_0001_1111;
parameter WHITE = 24'hFFFFFF;
parameter BLACK = 24'h000000; 
parameter DOTS_WIDTH = 255;
parameter LEFT_X = 10'd192;
parameter RIGHT_X = LEFT_X + DOTS_WIDTH;
parameter TOP_Y = 10'd138;
// Oversquare sized
parameter BOTTOM_Y = TOP_Y + 80; 
parameter BAT_L_X = RIGHT_X - 50;
parameter BAT_R_X = BAT_L_X + 50;
parameter BAT_T_Y = BOTTOM_Y + 28;
parameter BAT_B_Y = BAT_T_Y + 80;
parameter BAT_MIDPT_X = BAT_L_X + 25; 
integer i,j; 
wire [23:0] color;
wire [23:0] c1;
wire [23:0] c2;
wire [23:0] c3a;
wire [23:0] c3b;
wire [23:0] c3c;
wire [23:0] c4;
wire [23:0] c5;
wire [23:0] c6;
wire [23:0] c7;
wire [23:0] c8;
wire [23:0] c9;
wire [23:0] c10;
wire [23:0] c11;
wire [23:0] c12; 
wire [2:0] p1;
assign c9 = {p1, p1, p1, p1, p1, p1, p1, p1};
wire [2:0] p2;
assign c10 = {16'b0, p2[1:0], p2, p2};
wire [2:0] p3;
assign c11 = {8'b0, p3[1:0], p3, p3, 8'b0};
wire [2:0] p4; 

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\display.v 
assign c12 = {p4[1:0], p4, p4, 16'b0}; 
56 
57 
58 
59 
60 
61 

reg [7:0] error_count; 
char_string_display title_csd(clock, pixel, line, p1, {8'd71, 8'd101,
8'd110, 8'd101, 8'd114, 8'd97, 8'd108, 8'd105, 8'd122, 8'd101, 8'd100,
8'd32, 8'd76, 8'd111, 8'd99, 8'd97, 8'd108, 8'd32, 8'd68, 8'd101, 8'd99,
8'd111, 8'd100, 8'd105, 8'd110, 8'd103}, 100, 50);
defparam title_csd.NCHAR = 26;
char_string_display ber_csd(clock, pixel, line, p2, {8'd66, 8'd69,
8'd82}, LEFT_X, BOTTOM_Y + 10);
defparam ber_csd.NCHAR = 3;
defparam ber_csd.SCALE = 2;
char_string_display snr_csd(clock, pixel, line, p3, {8'd83, 8'd78,
8'd82}, LEFT_X + 100, BOTTOM_Y + 10);
defparam snr_csd.NCHAR = 3;
defparam snr_csd.SCALE = 2;
char_string_display power_csd(clock, pixel, line, p4, {8'd80, 8'd111,
8'd119, 8'd101, 8'd114}, LEFT_X + 200, BOTTOM_Y + 10);
defparam power_csd.NCHAR = 5;
defparam power_csd.SCALE = 2;

62
63 
64 
65
66 
67 
68 
69
70 
71 
72 
73
74 
75 
76 
77 
78 
79 

80 

81 
82 

83 
84 
85 
86 
87 
88 
89 

90 
91 

horizontal_line time_axis(.start_x(LEFT_X), .end_x(RIGHT_X),
.y(BOTTOM_Y), .pixel(pixel), .line(line), .color(c1));
vertical_line data_axis(.x(LEFT_X), .start_y(TOP_Y), .end_y(BOTTOM_Y),
.pixel(pixel), .line(line), .color(c2));
dots ber_dots(.clock(clock), .enable(enable),
.current_word(error_count), .left_x(LEFT_X), .bottom_y(BOTTOM_Y),
.pixel(pixel), .line(line), .color(c3a));
dots snr_dots(.clock(clock), .enable(enable), .current_word(8'd50),
.left_x(LEFT_X), .bottom_y(BOTTOM_Y), .pixel(pixel), .line(line),
.color(c3b));
defparam snr_dots.DOT_COLOR = 24'h00FF00;
dots power_dots(.clock(clock), .enable(enable), .current_word(8'd40),
.left_x(LEFT_X), .bottom_y(BOTTOM_Y), .pixel(pixel), .line(line),
.color(c3c));
defparam power_dots.DOT_COLOR = 24'hFF0000;
horizontal_line battery_bottom(.start_x(BAT_L_X), .end_x(BAT_R_X),
.y(BAT_B_Y), .pixel(pixel), .line(line), .color(c4));
vertical_line battery_left(.x(BAT_L_X), .start_y(BAT_T_Y),
.end_y(BAT_B_Y), .pixel(pixel), .line(line), .color(c5));
vertical_line battery_right(.x(BAT_R_X), .start_y(BAT_T_Y),
.end_y(BAT_B_Y), .pixel(pixel), .line(line), .color(c6));
horizontal_line battery_top(.start_x(BAT_L_X), .end_x(BAT_R_X),
.y(BAT_T_Y), .pixel(pixel), .line(line), .color(c7));
gauge power_usage_gauge(.start_x(BAT_L_X), .end_x(BAT_R_X),
.y(BAT_B_Y), .value(power_usage), .pixel(pixel), .line(line),
.color(c8)); 
assign color = c1 | c2 | c3a | c3b | c3c | c4 | c5 | c6 | c7 | c8 | c9 

Page: 2 

File: C:\Documents and Settings\Matt\Desktop\walsh\display.v 
| c10 | c11 | c12;
91
reg [5:0] ticker;

92 
reg [7:0] new_data_count;

93 
always @(posedge clock) begin

94 
if (reset || enable) begin

95

error_count <= 8'b0;

96

new_data_count <= 8'b0;

97

end else if (got_new_data && new_data_count < 5) begin
98

new_data_count <= new_data_count + 1;
99 
error_count <= error_count + current_error_count;
100 
end 
101 
if (reset) begin
102 
ticker <= 0;
103 
end else begin
104 
if (enable) begin
105 
ticker <= ticker + 10;
106 
end 
107 
end 
108 
end 
109 
110  endmodule 
111 

Page: 3 

File: C:\Documents and Settings\Matt\Desktop\walsh\display_test.v 
`timescale 1ns / 1ps 
1
2
module display_test_v; 
3
4
// Inputs

5
reg got_new_data;

6
reg clock;

7
reg reset;

8
reg enable;

9
reg [9:0] pixel; 

10
reg [9:0] line;

11
reg [2:0] current_error_count; 

12
13
// Outputs

14
wire [23:0] color;

15
wire [5:0] error_count;

16
17
reg up, down;

18
wire [5:0] addr; 

19
control control_uut(

20
.clk(clock),

21
.reset(reset),

22
.up(up),

23
.down(down),

24
.addr(addr)

25
);

26
// Instantiate the Unit Under Test (UUT) 

27
display uut (

28
.got_new_data(got_new_data),

29
.clock(clock),

30
.reset(reset),

31
.enable(enable),

32
.pixel(pixel),

33
.line(line),

34
.color(color),

35
.current_error_count(current_error_count),

36
.error_count(error_count) 

37
); 
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56

reg [4:0] ctr;

always #10 clock=~clock;

always #10 ctr=ctr+1;

integer i; integer j;

initial begin

// Initialize Inputs

got_new_data = 0;

clock = 0;

ctr = 0;

reset = 0;

enable = 0;

pixel = 0;

line = 0;

current_error_count = 0;

// Wait 100 ns for global reset to finish 

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\display_test.v 
#100;
57 
for (j = 0; j < 100; j = j + 1) begin
58 
for (i = 0; i < 10; i = i + 1) begin
59
current_error_count = ctr[2:0];
60 
got_new_data = 1;
61 
end 
62 
//got_new_data = 0;
63 
enable = 1;
64 
#20;
65 
enable = 0;
66 
end 
67 
// Add stimulus here 
68 
69 
end 
70 
71 
72  endmodule 
73 

Page: 2 

File: C:\Documents and Settings\Matt\Desktop\walsh\divider.v 
`timescale 1ns / 1ps 
1
2
module divider(clock, enable, reset);

3
input reset, clock;

4
5
 output enable; 
6
7
reg enable;

8
reg [25:0] cnt;

9
10
 always @(posedge clock) begin
11
if (reset == 1) begin

12
cnt <= 26'd0;

13
enable <= 1'b0;

14
end else if (cnt == 26'd6299999) begin
15
cnt <= 26'd0;
16
enable <= 1'b1;
17
end else begin

18
cnt <= cnt + 1;

19
enable <= 1'b0;

20
end

21
 end

22
endmodule

23

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\dots.v 
`timescale 1ns / 1ps 
1
2 
3  module dots(clock, enable, current_word, left_x, bottom_y, pixel, line,
color);
input clock, enable;
4 
input [9:0] left_x, bottom_y;
5 
input [9:0] pixel, line;
6 
input [7:0] current_word; 
7 
8 
output [23:0] color; 
9 
10 
parameter DOT_COLOR = 24'h0000FF;
11 
parameter BLACK = 24'h0;
12 
parameter DOTS_WIDTH = 255; 
13 
14 
reg [23:0] color;
15 
reg [7:0] dot_data [DOTS_WIDTH:0]; // DOTS_WIDTH 8-bit words
16 
integer i; 
17 
18 
integer j;
19 
reg [7:0] ctr; 
20 
21 
always @(posedge clock) begin
22 
if (enable) begin
23 
// Shift dots backward
24 
for (i = 0; i < DOTS_WIDTH; i = i + 1) begin
25 
dot_data[i] <= dot_data[i + 1];
26 
end 
27 
28 
dot_data[DOTS_WIDTH] <= current_word;
29 
end 
30 
end 
31 
32 
always @(current_word or clock or enable or pixel or line or left_x or
33 
bottom_y) begin
if (pixel > left_x && line < bottom_y && pixel <= left_x + 256 &&
34 
line >= bottom_y - 64
&& line == bottom_y - dot_data[pixel - left_x] - 1) begin
35 
color = DOT_COLOR;
36 
end else begin
37 
color = BLACK;
38 
end 
39 
end 
40 
41 
42  endmodule 

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\feedback_path.v 
`timescale 1ns / 1ps 
1
2 
3  module feedback_path(enable, reset, clk, enabled, decrement, increment,
error_count, num_fhts, saw_button);
input [2:0] error_count;
4 
input enable, reset, clk, enabled, decrement, increment;
5 
output [2:0] num_fhts;
6 
output saw_button; 
7 
8 
reg [2:0] num_fhts; 
9 
10 
parameter TARGET_BER = 8'd10; 
11 
12 
reg saw_button;
13 
always @(posedge clk) begin
14 
if (reset) begin
15 
num_fhts <= 3'd7;
16 
saw_button <= 0;
17 
end else begin
18 
if (enabled) begin
19 
if (enable) begin
20 
if (error_count > TARGET_BER) begin
21 
if (num_fhts < 7) begin
22 
num_fhts <= num_fhts + 1;
23 
end 
24 
end else begin
25 
if (num_fhts > 0) begin
26 
num_fhts <= num_fhts - 1;
27 
end 
28 
end 
29 
end 
30 
end else if (decrement) begin
31 
if (!saw_button) begin
32 
saw_button <= 1;
33 
if (num_fhts > 0) begin
34 
num_fhts <= num_fhts - 1;
35 
end 
36 
end 
37 
end else if (increment) begin
38 
if (!saw_button) begin
39 
saw_button <= 1;
40 
if (num_fhts < 7) begin
41 
num_fhts <= num_fhts + 1;
42 
end 
43 
end 
44 
end else begin
45 
saw_button <= 0;
46 
end 
47 
end 
48 
end 
49 
50  endmodule 

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\fht.m 
function y = fht(x)

1
% Returns fast Hadamard transform of columns of x

2
3
L = length(x(:,1));

4
n = log2(L);

5
y = x;

6
for i=1:n

7
 tmp(1:L/2,:) = y(1:2:L,:) + y(2:2:L,:);
8
tmp(L/2+1:L,:) = y(1:2:L,:) - y(2:2:L,:);
9
y = tmp;
10
end 
11

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\fht_8_symbol.v 
`timescale 1ns / 1ps
1
module fht_8_symbol(reset, clk, upper_input, lower_input, upper_corr,
2 
lower_corr, ready);
input reset, clk;
3
parameter WIDTH = 10;
4
input signed [WIDTH-1:0] upper_input, lower_input;
5
output ready;
6
output [WIDTH-1:0] upper_corr, lower_corr; 
7
8 
reg [4:0] ctr; 
9
10 
// Combinational logic
11
//
12
// NORMAL STAGES
13
wire signed [WIDTH-1:0] s5_upper_out, s5_lower_out;
14
wire signed [WIDTH-1:0] s6_upper_out, s6_lower_out, s7_upper_out,
15
s7_lower_out;
wire signed [WIDTH-1:0] upper_fly_out, lower_fly_out; 
16
17 
wire twoenable, oneenable; 
18
19 
 fht_stage s6(reset, clk, ctr[1], upper_input, lower_input,
20
s6_upper_out, s6_lower_out);
defparam s6.SIZE = 2;
21
 fht_stage s7(reset, clk, ctr[0], s6_upper_out, s6_lower_out,
22
s7_upper_out, s7_lower_out);
defparam s7.SIZE = 1;
23
24 
 // FINAL STAGE
25
 // Abs() takes the place of squaring the correlation values
26
 assign upper_corr = (s7_upper_out + s7_lower_out > 0) ? (s7_upper_out
27
+ s7_lower_out) 
: -(s7_upper_out + 
28
s7_lower_out);
assign lower_corr = (s7_upper_out - s7_lower_out > 0) ? (s7_upper_out
29
- s7_lower_out) 
: -(s7_upper_out -
30
s7_lower_out);
// Clocked logic
31
 reg [5:0] largest_component_idx;
32
 reg signed [WIDTH-1:0] largest_component_val;
33
 reg ready;
34
35 
 always @(posedge clk) begin
36
 if (reset) begin
37
ctr <= 0;
38 
ready <= 1'b0;
39 
 end else begin
40
 // Ready signal indicates we're done
41
 ready <= (ctr == 5'd31);
42
ctr <= ctr + 1;
43 
 end 
44
 end 
45
46  endmodule 
47 

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\fht_64_symbol.v 
`timescale 1ns / 1ps
1
// 64-symbol FHT. From Bahl's paper. During cycles 0-31, takes inputs
2 
0-31 on the upper input and 32-63 on the lower input.
// During cycles 31-62, outputs 64 correlation coefficients (first on
3 
upper, second lower, third upper second cycle, etc.)
module fht_64_symbol(reset, clk, upper_input, lower_input,
4 
largest_component_idx, largest_component_val, ready, upper_fly_out,
lower_fly_out, ctr);
input reset, clk;
parameter WIDTH = 10;
input signed [WIDTH-1:0] upper_input, lower_input;
output ready;
output [5:0] largest_component_idx;
output [WIDTH-1:0] largest_component_val;
output [WIDTH-1:0] upper_fly_out, lower_fly_out;
output [5:0] ctr;
// 7 bit counter
reg [5:0] ctr; 
// First few stages
wire signed [WIDTH-1:0] s3_upper_out, s3_lower_out;
wire signed [WIDTH-1:0] s4_upper_out, s4_lower_out, s5_upper_out,
s5_lower_out;
wire signed [WIDTH-1:0] s6_upper_out, s6_lower_out, s7_upper_out,
s7_lower_out;
wire signed [WIDTH-1:0] upper_fly_out, lower_fly_out; 
 fht_stage s3(reset, clk, ctr[4], upper_input, lower_input,
s3_upper_out, s3_lower_out);
defparam s3.SIZE = 16;
 fht_stage s4(reset, clk, ctr[3], s3_upper_out, s3_lower_out,
s4_upper_out, s4_lower_out);
defparam s4.SIZE = 8;
 fht_stage s5(reset, clk, ctr[2], s4_upper_out, s4_lower_out,
s5_upper_out, s5_lower_out);
defparam s5.SIZE = 4;
 fht_stage s6(reset, clk, ctr[1], s5_upper_out, s5_lower_out,
s6_upper_out, s6_lower_out);
defparam s6.SIZE = 2;
 fht_stage s7(reset, clk, ctr[0], s6_upper_out, s6_lower_out,
s7_upper_out, s7_lower_out);
defparam s7.SIZE = 1;
 // Last stage
 // abs takes the place of squaring
 assign upper_fly_out = (s7_upper_out + s7_lower_out > 0) ?
(s7_upper_out + s7_lower_out) 
: -(s7_upper_out + 
s7_lower_out);
assign lower_fly_out = (s7_upper_out - s7_lower_out > 0) ?
(s7_upper_out - s7_lower_out) 
: -(s7_upper_out  (cid:173)
s7_lower_out); 
 reg [5:0] largest_component_idx;
 reg signed [WIDTH-1:0] largest_component_val; 

5
6
7
8
9
10
11
12
13
14
15 
16
17
18
19
20
21 
22
23
24
25
26
27
28
29
30
31
32 
33
34
35
36
37
38
39 
40
41

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\fht_64_symbol.v 
 reg ready, ready_thrown;

42
43

 always @(posedge clk) begin

44
 if (reset) begin

45

ctr <= 0;

46

largest_component_idx <= 10'b0;

47

largest_component_val <= 10'b0;

48

ready <= 1'b0;

49

ready_thrown <= 0;
50

 end else begin
51
 // Comparator
52
largest_component_idx <= reset || ready ? 10'b0 :
53 
 (upper_fly_out > largest_component_val &&
54
upper_fly_out > lower_fly_out) ? (ctr - 31) * 2 :
lower_fly_out > largest_component_val ? (ctr  (cid:173)
55
31) * 2 + 1 : 
largest_component_idx;
56
 largest_component_val <= reset || ready ? 10'b0 :
57
 (upper_fly_out > largest_component_val &&
58
upper_fly_out > lower_fly_out) ? upper_fly_out :
lower_fly_out > largest_component_val ? 
59
lower_fly_out : 
largest_component_val;

60
 if (ctr == 6'd62 && !ready_thrown) begin 

61
ready <= 1;

62 
ready_thrown <= 1;

63 
end

64 
ctr <= ready ? 6'd0 : ctr + 1;

65 
 end

66
 end

67
68  endmodule

69


Page: 2 

File: C:\Documents and Settings\Matt\Desktop\walsh\fht_stage.v 
`timescale 1ns / 1ps
1
// Single FHT stage, from Bahl's paper.
2
module fht_stage(reset, clk, enable, upper_input, lower_input,
3 
upper_output, lower_output);
input reset, clk, enable;
4
5 
parameter WIDTH = 10;
6
input signed [WIDTH-1:0] upper_input, lower_input; 
7
8 
output signed [WIDTH-1:0] upper_output, lower_output;
9
parameter SIZE = 64; 
10
11 
 wire signed [WIDTH-1:0] upper_fly_out, lower_fly_out, first_mux_out,
12
upper_sr_in, lower_sr_in;
wire signed [WIDTH-1:0] upper_sr_out, lower_sr_out,
13
upperright_mux_out, lowerright_mux_out;
wire signed [WIDTH-1:0] upper_output, lower_output;
14
15 
 assign upper_fly_out = upper_input + lower_input;
16
 assign lower_fly_out = upper_input - lower_input;
17
 assign first_mux_out = enable ? lower_fly_out : upper_fly_out;
18
19 
 // always shift top sr forward
20
 assign upper_sr_in = first_mux_out;
21
 shift_register upper_sr(reset, clk, 1'b1, upper_sr_in, upper_sr_out);
22
 defparam upper_sr.SIZE = SIZE;
23
 defparam upper_sr.WIDTH = WIDTH;
24
25 
 // on !enable, shift bottom register forward
26
 assign lower_sr_in = lower_fly_out;
27
 shift_register lower_sr(reset, clk, !enable, lower_sr_in,
28
lower_sr_out);
defparam lower_sr.SIZE = SIZE;
29
 defparam lower_sr.WIDTH = WIDTH;
30
31 
 assign upperright_mux_out = !enable ? lower_sr_out : upper_sr_out;
32
 assign lowerright_mux_out = !enable ? upper_sr_out : upper_fly_out;
33
34 
 assign upper_output = upperright_mux_out;
35
 assign lower_output = lowerright_mux_out;
36
37  endmodule 

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\final_labkit.v 
1  ////////////////////////////////////////////////////////////////////////
///////
//
2
// 6.111 FPGA Labkit -- Template Toplevel Module for Lab 4 (Spring 2006)
3
//
4
//
5
// Created: March 13, 2006
6
// Author: Nathan Ickes
7
//
8
////////////////////////////////////////////////////////////////////////
9 
/////// 
10 
11  module labkit (beep, audio_reset_b, ac97_sdata_out, ac97_sdata_in,
ac97_synch,
ac97_bit_clock,

12
13

 vga_out_red, vga_out_green, vga_out_blue, vga_out_sync_b,

14
 vga_out_blank_b, vga_out_pixel_clock, vga_out_hsync, 

15
 vga_out_vsync,

16
17

 tv_out_ycrcb, tv_out_reset_b, tv_out_clock, tv_out_i2c_clock,

18
 tv_out_i2c_data, tv_out_pal_ntsc, tv_out_hsync_b, 

19
 tv_out_vsync_b, tv_out_blank_b, tv_out_subcar_reset, 

20
21

 tv_in_ycrcb, tv_in_data_valid, tv_in_line_clock1, 

22
 tv_in_line_clock2, tv_in_aef, tv_in_hff, tv_in_aff,

23
 tv_in_i2c_clock, tv_in_i2c_data, tv_in_fifo_read, 

24
 tv_in_fifo_clock, tv_in_iso, tv_in_reset_b, tv_in_clock, 

25
26

 ram0_data, ram0_address, ram0_adv_ld, ram0_clk, ram0_cen_b,

27
 ram0_ce_b, ram0_oe_b, ram0_we_b, ram0_bwe_b, 

28
29

 ram1_data, ram1_address, ram1_adv_ld, ram1_clk, ram1_cen_b,

30
 ram1_ce_b, ram1_oe_b, ram1_we_b, ram1_bwe_b, 

31
32

 clock_feedback_out, clock_feedback_in, 

33
34

 flash_data, flash_address, flash_ce_b, flash_oe_b, flash_we_b,

35
 flash_reset_b, flash_sts, flash_byte_b,

36
37

 rs232_txd, rs232_rxd, rs232_rts, rs232_cts,

38
39

 mouse_clock, mouse_data, keyboard_clock, keyboard_data, 

40
41

 clock_27mhz, clock1, clock2,

42
43

 disp_blank, disp_data_out, disp_clock, disp_rs, disp_ce_b, 

44
 disp_reset_b, disp_data_in,

45
46

 button0, button1, button2, button3, button_enter, button_right,

47
 button_left, button_down, button_up,

48
49

 switch,

50
51

 led, 

52
53


Page: 1

File: C:\Documents and Settings\Matt\Desktop\walsh\final_labkit.v 
user1, user2, user3, user4, 
54
55 
daughtercard, 
56
57 
 systemace_data, systemace_address, systemace_ce_b,
58
systemace_we_b, systemace_oe_b, systemace_irq,
59
systemace_mpbrdy, 
60 
 analyzer1_data, analyzer1_clock, 

61
 analyzer2_data, analyzer2_clock,

62
 analyzer3_data, analyzer3_clock,

63
 analyzer4_data, analyzer4_clock);

64
65

 output beep, audio_reset_b, ac97_synch, ac97_sdata_out; 

66
 input  ac97_bit_clock, ac97_sdata_in;

67
68

 output [7:0] vga_out_red, vga_out_green, vga_out_blue;

69
 output vga_out_sync_b, vga_out_blank_b, vga_out_pixel_clock,

70
 vga_out_hsync, vga_out_vsync;

71
72

 output [9:0] tv_out_ycrcb; 

73
 output tv_out_reset_b, tv_out_clock, tv_out_i2c_clock,

74
tv_out_i2c_data,

 tv_out_pal_ntsc, tv_out_hsync_b, tv_out_vsync_b, tv_out_blank_b,

75
 tv_out_subcar_reset;

76
77

 input  [19:0] tv_in_ycrcb; 

78
 input  tv_in_data_valid, tv_in_line_clock1, tv_in_line_clock2, 

79
tv_in_aef,
 tv_in_hff, tv_in_aff;
80
 output tv_in_i2c_clock, tv_in_fifo_read, tv_in_fifo_clock, tv_in_iso,
81
 tv_in_reset_b, tv_in_clock;
82
 inout  tv_in_i2c_data;
83
84 
 inout  [35:0] ram0_data;
85
 output [18:0] ram0_address;
86
 output ram0_adv_ld, ram0_clk, ram0_cen_b, ram0_ce_b, ram0_oe_b,
87
ram0_we_b;

 output [3:0] ram0_bwe_b;

88
89

 inout  [35:0] ram1_data;

90
 output [18:0] ram1_address;

91
 output ram1_adv_ld, ram1_clk, ram1_cen_b, ram1_ce_b, ram1_oe_b,

92
ram1_we_b;

 output [3:0] ram1_bwe_b;

93
94

 input  clock_feedback_in;

95
 output clock_feedback_out; 

96
97

 inout  [15:0] flash_data;

98
 output [24:0] flash_address;

99
 output flash_ce_b, flash_oe_b, flash_we_b, flash_reset_b,
100
flash_byte_b;
input  flash_sts;
101
102 
 output rs232_txd, rs232_rts; 
103

Page: 2 

File: C:\Documents and Settings\Matt\Desktop\walsh\final_labkit.v 
input  rs232_rxd, rs232_cts; 
104
105 
input  mouse_clock, mouse_data, keyboard_clock, keyboard_data; 
106
107 
input  clock_27mhz, clock1, clock2; 
108
109 
output disp_blank, disp_clock, disp_rs, disp_ce_b, disp_reset_b;
110
input  disp_data_in;
111
output  disp_data_out; 
112
113 
 input  button0, button1, button2, button3, button_enter,
114
button_right,
button_left, button_down, button_up;
115
 input  [7:0] switch;
116
 output [7:0] led;
117
118 
 inout [31:0] user1, user2, user3, user4;
119
120 
 inout [43:0] daughtercard;
121
122 
 inout  [15:0] systemace_data;
123
 output [6:0]  systemace_address;
124
 output systemace_ce_b, systemace_we_b, systemace_oe_b;
125
 input  systemace_irq, systemace_mpbrdy;
126
127 
 output [15:0] analyzer1_data, analyzer2_data, analyzer3_data,
128
 analyzer4_data;
129
 output analyzer1_clock, analyzer2_clock, analyzer3_clock,
130
analyzer4_clock; 
131 
132 

////////////////////////////////////////////////////////////////////////
////
//
 // I/O Assignments
 //
////////////////////////////////////////////////////////////////////////
//// 
 // Audio Input and Output

 assign beep= 1'b0;

 assign audio_reset_b = 1'b0;

 assign ac97_synch = 1'b0;

 assign ac97_sdata_out = 1'b0; 

 // Video Output 

 assign tv_out_ycrcb = 10'h0;

 assign tv_out_reset_b = 1'b0; 

 assign tv_out_clock = 1'b0;

 assign tv_out_i2c_clock = 1'b0;

 assign tv_out_i2c_data = 1'b0;

 assign tv_out_pal_ntsc = 1'b0;

 assign tv_out_hsync_b = 1'b1; 

 assign tv_out_vsync_b = 1'b1; 

 assign tv_out_blank_b = 1'b1; 


133
134
135
136 

137 
138
139
140
141
142
143

144
145
146
147
148
149
150
151
152
153

Page: 3 

File: C:\Documents and Settings\Matt\Desktop\walsh\final_labkit.v 
assign tv_out_subcar_reset = 1'b0; 
154
155 
// Video Input
156
assign tv_in_i2c_clock = 1'b0;
157
assign tv_in_fifo_read = 1'b0;
158
assign tv_in_fifo_clock = 1'b0;
159
assign tv_in_iso = 1'b0;
160
assign tv_in_reset_b = 1'b0;
161
assign tv_in_clock = 1'b0;
162
assign tv_in_i2c_data = 1'bZ; 
163
164 
// SRAMs
165
assign ram0_data = 36'hZ;
166
assign ram0_address = 19'h0;
167
assign ram0_adv_ld = 1'b0;
168
assign ram0_clk = 1'b0;
169
assign ram0_cen_b = 1'b1;
170
assign ram0_ce_b = 1'b1;
171
assign ram0_oe_b = 1'b1;
172
assign ram0_we_b = 1'b1;
173
assign ram0_bwe_b = 4'hF;
174
assign ram1_data = 36'hZ;
175
assign ram1_address = 19'h0;
176
assign ram1_adv_ld = 1'b0;
177
assign ram1_clk = 1'b0;
178
assign ram1_cen_b = 1'b1;
179
assign ram1_ce_b = 1'b1;
180
assign ram1_oe_b = 1'b1;
181
assign ram1_we_b = 1'b1;
182
assign ram1_bwe_b = 4'hF;
183
assign clock_feedback_out = 1'b0; 
184
185 
// Flash ROM
186
assign flash_data = 16'hZ;
187
assign flash_address = 24'h0;
188
assign flash_ce_b = 1'b1;
189
assign flash_oe_b = 1'b1;
190
assign flash_we_b = 1'b1;
191
assign flash_reset_b = 1'b0;
192
assign flash_byte_b = 1'b1; 
193
194 
// RS-232 Interface
195
assign rs232_txd = 1'b1;
196
assign rs232_rts = 1'b1; 
197
198 
// LED Displays
199
//assign disp_blank = 1'b1;
200
//assign disp_clock = 1'b0;
201
//assign disp_rs = 1'b0;
202
//assign disp_ce_b = 1'b1;
203
//assign disp_reset_b = 1'b0;
204
//assign disp_data_out = 1'b0; 
205
206 
// Buttons, Switches, and Individual LEDs
207
//assign led = 8'hFF; 
208
209 

Page: 4 

File: C:\Documents and Settings\Matt\Desktop\walsh\final_labkit.v 
// User I/Os
210
assign user1 = 32'hZ;
211
assign user2 = 32'hZ;
212
assign user3 = 32'hZ;
213
assign user4 = 32'hZ; 
214
215 
// Daughtercard Connectors
216
assign daughtercard = 44'hZ; 
217
218 
// SystemACE Microprocessor Port
219
assign systemace_data = 16'hZ;
220
assign systemace_address = 7'h0;
221
assign systemace_ce_b = 1'b1;
222
assign systemace_we_b = 1'b1;
223
assign systemace_oe_b = 1'b1; 
224
225 
// Logic Analyzer
226
assign analyzer1_data = 16'h0;
227
assign analyzer1_clock = 1'b1;
228
assign analyzer2_data = 16'h0;
229
assign analyzer2_clock = 1'b1;
230
assign analyzer3_data = 16'h0;
231
assign analyzer3_clock = 1'b1;
232
assign analyzer4_data = 16'h0;
233
assign analyzer4_clock = 1'b1; 
234
235 
236 

////////////////////////////////////////////////////////////////////////
////
//
 // Final Project Components
 //
////////////////////////////////////////////////////////////////////////
//// 
//

 // DCM BLOCK

 //

// Generate a 31.5MHz pixel clock from clock_27mhz 

 wire pclk, pixel_clock; 

 DCM pixel_clock_dcm (.CLKIN(clock_27mhz), .CLKFX(pclk)); 

 // synthesis attribute CLKFX_DIVIDE of pixel_clock_dcm is 6 

 // synthesis attribute CLKFX_MULTIPLY of pixel_clock_dcm is 7 

 // synthesis attribute CLK_FEEDBACK of pixel_clock_dcm is "NONE" 

 BUFG pixel_clock_buf (.I(pclk), .O(pixel_clock)); 


237
238
239
240 

241 
242 
243
244
245 
246
247
248
249
250
251
252

253

254 
255 
256 
257 
258 
259 
260 
261 

parameter WIDTH = 10;

//

// Heartbeat

//

reg [29:0] ctr;

reg alt;

reg [7:0] ticker;

wire [WIDTH-1:0] symbol;


Page: 5 

File: C:\Documents and Settings\Matt\Desktop\walsh\final_labkit.v 
reg [3:0] hold_symbol;
262 
wire ready;
263 
wire [5:0] decoded_bits;
264 
reg [5:0] hold_decoded_bits;
265 
always @(posedge pixel_clock) begin
266 
ctr <= ctr + 1;
267 
if (ctr > 30'd6300000) begin
268 
ctr <= 30'd0;
269 
alt <= ~alt;
270 
ticker <= ticker + 1;
271 
hold_symbol <= symbol[3:0];
272 
end 
273 
if (ready) begin
274 
hold_decoded_bits <= decoded_bits;
275 
end 
276 
end 
277 
278 
assign led[7] = alt;
279 
//assign led[6:4] = 8'b1111111;
280 
//assign led[6:3] = hold_symbol;
281 
//assign led[2:1] = 2'b11;
282 
assign led[4:1] = decoded_bits; 
283 
284 
//
285 
// SYNC BLOCK
286 
//
287 
wire reset, deb_button_up, deb_button_down, deb_button_left,
288 
deb_button_right;
debounce reset_debouncer(1'b0, pixel_clock, ~button0, reset);
289 
debounce up_debouncer(1'b0, pixel_clock, ~button_up, deb_button_up);
290 
debounce down_debouncer(1'b0, pixel_clock, ~button_down,
291 
deb_button_down);
debounce left_debouncer(1'b0, pixel_clock, ~button_left,
292 
deb_button_left);
debounce right_debouncer(1'b0, pixel_clock, ~button_right,
293 
deb_button_right);
assign led[6] = deb_button_left;
294 
assign led[5] = deb_button_right;
295 
assign led[0] = reset;
296 
297 
 //
298
// CLOCK BLOCK
299 
//
300 
wire enable;
301 
divider enabler(pixel_clock, enable, reset);
302 
reg pace;
303 
reg [6:0] pace_ctr;
304 
always @(posedge pixel_clock) begin
305 
if (reset) begin
306 
pace_ctr <= 0;
307 
pace <= 0;
308 
end else begin
309 
if (pace_ctr == 129) begin
310 
pace <= 1;
311 
pace_ctr <= pace_ctr + 1;
312 
end else if (pace_ctr == 130) begin 
313 

Page: 6 

File: C:\Documents and Settings\Matt\Desktop\walsh\final_labkit.v 
pace <= 0;
314 
pace_ctr <= 0;
315 
end else begin
316 
pace_ctr <= pace_ctr + 1;
317 
end 
318 
end 
319 
end 
320 
321 
//
322 
// ROM BLOCK
323 
// 
324 
325 
wire [5:0] addr; 
326 
327 
rom uut (
328 
.addr(addr),
329 
.clk(pixel_clock),
330 
.dout(symbol)
331 
); 
332 
333 
//
334 
// CONTROL BLOCK
335 
//
336 
control mycontrol(pixel_clock, reset | enable | pace, deb_button_up,
337 
deb_button_down, addr); 
338 
//

339 
// WALSH BLOCK

340 
//

341 
wire [2:0] num_fhts;

342 
343

wire optimal;

344 
assign optimal = 1'b1;//deb_button_down; 

345 
//walsh mywalsh(reset, enable | pace, pixel_clock, num_fhts, optimal,

346 
symbol, decoded_bits, ready);

//wire [5:0] decoded_bits;
347 
assign decoded_bits = 6'b010101;
348 
assign ready = 1'b1;
349 
//
350 
// BER BLOCK
351 
//
352 
wire [2:0] error_count;
353 
wire [5:0] actual_bits;
354 
assign actual_bits = decoded_bits + 1;
355 
ber myber(decoded_bits, actual_bits, error_count);
356 
357 
//
358 
// FEEDBACK BLOCK
359 
//
360 
wire enabled;
361 
assign enabled = 1'b0;
362 
feedback_path myfeedback(enable, reset, pixel_clock, enabled,
363 
deb_button_left, deb_button_right, error_count, num_fhts); 
364 
//
365 
// VGA BLOCK 
366 

Page: 7 

File: C:\Documents and Settings\Matt\Desktop\walsh\final_labkit.v 
//

367 
wire [9:0] pixel_count;

368 
wire [9:0] line_count;

369 
wire [7:0] red;

370 
wire [7:0] green;

371 
wire [7:0] blue; 

372 
wire hsync, hblank, vsync, vblank; 

373 
wire hsync_delayed, vsync_delayed; 

374 
375

wire [7:0] new_data_ctr;

376 
wire [7:0] error_ctr;

377 
display mydisplay(ready, pixel_clock, reset, enable, pixel_count, 

378 
line_count, {red, green, blue}, decoded_bits[2:0], num_fhts, 

new_data_ctr, error_ctr);

vga myvga(pixel_clock, reset, hsync, vsync, sync_b, blank_b, 

pixel_count, line_count);

 // VGA output signals
 //
 // Inverting the clock to the DAC provides half a clock period for
signals
// to propagate from the FPGA to the DAC. 

 assign vga_out_pixel_clock = ~pixel_clock;

assign vga_out_red = red;

assign vga_out_green = green;

assign vga_out_blue = blue; 

assign vga_out_hsync = hsync;

assign vga_out_vsync = vsync;

assign vga_out_blank_b = blank_b;

assign vga_out_sync_b = sync_b; 

wire [639:0] final_dots;

wire [79:0] symbol_dots;

wire [79:0] ticker_dots;

wire [79:0] error_dots;

wire [79:0] decoded_dots;

wire [79:0] data_ctr_dots; 

wire [79:0] error_ctr_dots; 

wire [79:0] fhts_dots;

alpha_dots symbol_dots_guy(pixel_clock, hold_symbol[3:0],

symbol_dots);

alpha_dots ticker_dots_guy(pixel_clock, ticker[3:0], ticker_dots);
alpha_dots error_dots_guy(pixel_clock, {1'b0, error_count[2:0]},
error_dots);
alpha_dots decoded_dots_guy(pixel_clock, {1'b0, decoded_bits[2:0]},
decoded_dots);
alpha_dots data_ctr_dots_guy(pixel_clock, new_data_ctr[3:0],
data_ctr_dots);
alpha_dots error_ctr_dots_guy(pixel_clock, error_ctr[3:0],
error_ctr_dots);
alpha_dots fhts_dots_guy(pixel_clock, {1'b0, num_fhts}, fhts_dots);
 assign final_dots = {symbol_dots, error_dots, decoded_dots,
data_ctr_dots, error_ctr_dots, fhts_dots, 80'b0, ticker_dots};
alpha_display disp(pixel_clock, reset, deb_button_up, disp_blank,
disp_clock, disp_rs, disp_ce_b, disp_reset_b, disp_data_out, 

379 
380 
381
382
383
384
385
386 
387 
388 
389 
390 
391 
392 
393

394 
395 
396 
397 
398 
399 
400 
401 
402 
403 
404 
405 
406 
407 
408 
409 
410
411 

Page: 8 

File: C:\Documents and Settings\Matt\Desktop\walsh\final_labkit.v 
final_dots);
411
endmodule 
412 

Page: 9


File: C:\Documents and Settings\Matt\Desktop\walsh\font_rom.v 
/***********************************************************************
1
******** 
* 
This file is owned and controlled by Xilinx and must be used
2
* 
solely for design, simulation, implementation and creation of
* 
3
* 
design files limited to Xilinx devices or technologies. Use
* 
4
* 
* 
with non-Xilinx devices or technologies is expressly prohibited
5
* 
* 
and immediately terminates your license. 

6
*

*  

7
*

* 
8
* 
* 
9
* 
* 
10
* 
* 
11
* 
* 
12
* 
* 
13
* 
* 
14
* 
* 
15
* 
* 
16
* 
* 
17
* 
* 
18
* 
* 
19
* 
* 
20
*

*  

21
*

* 
22
* 
* 
23
* 
* 
24
*

*  

25
*

* 
26
* 
* 
27
* 
************************************************************************ 
28
*******/ 

XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR 
XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION
AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION
OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS
IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY 
WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF 
INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE.  


Xilinx products are not intended for use in life support
appliances, devices, or systems. Use in such applications are
expressly prohibited.


(c) Copyright 1995-2004 Xilinx, Inc.

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\font_rom.v 
29  // The synopsys directives "translate_off/translate_on" specified below
are 
30  // supported by XST, FPGA Compiler II, Mentor Graphics and Synplicity
synthesis
// tools. Ensure they are correct for your synthesis tool(s). 
31
32 
// You must compile the wrapper file font_rom.v when simulating
33
// the core, font_rom. When compiling the wrapper file, be sure to
34
// reference the XilinxCoreLib Verilog simulation library. For detailed
35
// instructions, please refer to the "CORE Generator Help". 
36
37 
`timescale 1ns/1ps 
38
39 
module font_rom(
40
addr,

41 
clk,

42 
dout);

43 
44

45

46
47
48
49 
50
51 
52
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 

input [10 : 0] addr;
input clk;
output [7 : 0] dout; 
// synopsys translate_off 
 BLKMEMSP_V6_1 #(

11, // c_addr_width

"0",  // c_default_data

1536, // c_depth

0,  // c_enable_rlocs

0,  // c_has_default_data

0,  // c_has_din

0,  // c_has_en

0,  // c_has_limit_data_pitch

0,  // c_has_nd

0,  // c_has_rdy

0,  // c_has_rfd

0,  // c_has_sinit

0,  // c_has_we

18, // c_limit_data_pitch 

"font_rom.mif", // c_mem_init_file

0,  // c_pipe_stages

0,  // c_reg_inputs

"0",  // c_sinit_value

8,  // c_width

0,  // c_write_mode

"0",  // c_ybottom_addr

1,  // c_yclk_is_rising

1,  // c_yen_is_high

"hierarchy1", // c_yhierarchy 

0,  // c_ymake_bmm

"16kx1",  // c_yprimitive_type 

1,  // c_ysinit_is_high

"1024", // c_ytop_addr 

0,  // c_yuse_single_primitive 

1,  // c_ywe_is_high


Page: 2 

File: C:\Documents and Settings\Matt\Desktop\walsh\font_rom.v 
1)  // c_yydisable_warnings 

83 
inst (

84 
.ADDR(addr),

85

.CLK(clk),

86

.DOUT(dout),

87

.DIN(),

88 
.EN(), 

89 
.ND(), 

90 
.RFD(),

91 
.RDY(),

92 
.SINIT(),

93 
.WE());

94 
95

96

// synopsys translate_on

97
98 
99  // FPGA Express black box declaration
// synopsys attribute fpga_dont_touch "true"
100
// synthesis attribute fpga_dont_touch of font_rom is "true" 
101
102
// XST black box declaration
103
// box_type "black_box"
104
// synthesis attribute box_type of font_rom is "black_box" 
105
106 
107  endmodule

108


Page: 3 

File: C:\Documents and Settings\Matt\Desktop\walsh\gauge.v 
`timescale 1ns / 1ps 
1
2 
module gauge(start_x, end_x, y, pixel, value, line, color);
3
input [9:0] start_x, end_x, y;
4 
input [9:0] pixel, line;
5 
input [2:0] value; 
6 
7 
output [23:0] color; 
8 
9 
reg [23:0] color; 
10 
11 
parameter WHITE = 24'hFFFFFF;
12 
parameter BLACK = 24'h0;
13 
parameter GREEN = 24'h00FF00;
14 
parameter YELLOW_GREEN = 24'h9acd32;
15 
parameter GREEN_YELLOW = 24'hadff2f;
16 
parameter ORANGE_RED = 24'hff4500;
17 
parameter ORANGE = 24'hffa500;
18 
parameter YELLOW = 24'hFFFF00; 
19 
20 
parameter RED = 24'hFF0000; 
21 
22 
always @(pixel or line or start_x or end_x or y) begin
23 
if (pixel > start_x + 1 && pixel < end_x - 1) begin
24 
if (line > y - (value + 1) * 10 && line < y) begin // value + 1 *
25 
5 is STUBBED 
if (line > y - 10 && line < y - 1) begin
26 
color = GREEN;
27 
end else if (line > y - 20 && line < y - 10) begin
28 
color = YELLOW_GREEN;
29 
end else if (line > y - 30 && line < y - 20) begin
30 
color = GREEN_YELLOW;
31 
end else if (line > y - 40 && line < y - 30) begin
32 
color = YELLOW;
33 
end else if (line > y - 50 && line < y - 40) begin
34 
color = YELLOW;
35 
end else if (line > y - 60 && line < y - 50) begin
36 
color = ORANGE;
37 
end else if (line > y - 70 && line < y - 60) begin
38 
color = ORANGE_RED;
39 
end else if (line > y - 80 && line < y - 70) begin
40 
color = RED;
41 
end else begin
42 
color = BLACK;
43 
end 
44 
end else begin
45 
color = BLACK;
46 
end 
47 
end else begin
48 
color = BLACK;
49 
end 
50 
end 
51 
52 
53 
54  endmodule 

Page: 1 

16:32:17 05/03/06 

HorizontalLine


File: C:\Documents and Settings\Matt\Desktop\walsh\horizontal_line.v 
`timescale 1ns / 1ps
1
////////////////////////////////////////////////////////////////////////
2 
////////
// Company:
3
// Engineer:
4
//
5
// Create Date: 
6 
// Design Name:
7
// Module Name: 

8 
9  // Project Name:
// Target Device:
10
// Tool versions:
11
// Description:
12
//
13
// Dependencies:
14
//
15
// Revision:
16
// Revision 0.01 - File Created
17
// Additional Comments:
18
//
19
////////////////////////////////////////////////////////////////////////
20
////////
module horizontal_line(start_x, end_x, y, pixel, line, color); 

21
input [9:0] start_x, end_x, y; 

22 
input [9:0] pixel, line; 
23 
24 
output [23:0] color; 
25 
26 
reg [23:0] color; 
27 
28 
parameter WHITE = 24'hFFFFFF;
29 
parameter BLACK = 24'h0; 
30 
31 
always @(pixel or line or start_x or end_x or y) begin
32 
if (pixel >= start_x && pixel <= end_x && line == y) begin
33 
color = WHITE;
34 
end else begin
35 
color = BLACK;
36 
end 
37 
end 
38 
39  endmodule 

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\optimal_decoder.v 
`timescale 1ns / 1ps 
1
2 
3  module optimal_decoder(reset, clk, symbol_in, six_bits, ready, ctr,
upper_input, lower_input, upper_output, lower_output, fht_ctr);
input reset, clk;
4 
parameter WIDTH=10;

5 
input [WIDTH-1:0] symbol_in;

6

output [5:0] six_bits;

7

output ready;
8

output [6:0] ctr;
9 
output [WIDTH-1:0] upper_input, lower_input;
10 
output [WIDTH-1:0] upper_output, lower_output;
11 
output [5:0] fht_ctr;
12 
wire ready;
13 
reg [WIDTH-1:0] symbols [63:0];
14 
15 
wire enable_fht;
16 
reg [WIDTH-1:0] upper_input, lower_input;
17 
wire [WIDTH-1:0] confidence;
18 
wire fht_ready;
19 
wire [5:0] fht_ctr;
20 
wire [WIDTH-1:0] upper_output, lower_output;
21 
fht_64_symbol fht(enable_fht | reset, clk, upper_input, lower_input,
22 
six_bits, confidence, fht_ready, upper_output, lower_output, fht_ctr); 
23 
reg [6:0] ctr;

24 
reg [3:0] saw_ready_ctr;

25 
assign enable_fht = (ctr < 65); 

26 
assign ready = fht_ready && !(saw_ready_ctr == 4'b11);

27 
always @(posedge clk) begin 

28 
if (reset) begin

29 
ctr <= 0;

30 
saw_ready_ctr <= 0;

31 
end else begin

32 
symbols[ctr-1] <= symbol_in;

33 
if (ctr > 63) begin

34 
upper_input <= symbols[ctr - 64];

35 
lower_input <= symbols[ctr - 32];

36 
end

37 
ctr <= ctr + 1;

38 
if (fht_ready) begin

39 
if (saw_ready_ctr < 10) begin 

40 
saw_ready_ctr <= saw_ready_ctr + 1;

41 
end

42 
end

43 
end

44 
end

45 
46  endmodule


Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\projected_FHT_8_6111.m 
1  % Walsh Decoding Implemented by Projected 8-Point Fast Hadamard
Transforms 
2 
3  num_codewords = 6; 
% Number of codewords 
4  num_FHT = 8; 
% Number of FHTs used to determine each triplet of 
bits (up to 8)
% dB

SNR = -8; 
5 
6

7  %%%%%%%%%%%%%%%%%%%%%% Generate Random Data

%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

bits = round(rand(6*num_codewords,1)); 

8
9 
10  %%%%%%%%%%%%%%%%%%%%%%%%%%% Walsh Encoder %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

11  H = de2bi(0:63); 

% Walsh codeword generator matrix
Walsh_chips =

12 
mod(reshape(H*reshape(bits,6,num_codewords),64*num_codewords,1),2); 
% Compute Walsh codewords
Walsh_index = bi2de(reshape(bits,6,num_codewords)')+1; 

13 
% Compute Walsh indices

14 
15  %%%%%%%%%%%%%% AWGN Channel %%%%%%%%%%%%%%%% 

r = (1-2*Walsh_chips) + sqrt(10^(-SNR/10))*randn(64*num_codewords,1);

16
17 
%%%%%%%%%%% Assume Perfect Synchronization %%%%%%%%%%%%%%
18
y = reshape(r,64,num_codewords); 

19
20 
21  %%%%%%%%%%% Decode Three Bits at a Time (When k=1, decode first 3 bits

of codeword; when k=4, decoder last 3 bits of codeword) %%%%%%%%%%%%
for i=0:num_codewords-1

22 
 for k=1:3:4 
23
24 
 %%%%%%%%%% Randomly Choose A Number of Distinct 3-Bit Patterns Equal
25
to Number of FHTs %%%%%%%%%%% 
[s,I] = sort(rand(8,1));
26
tmp = fliplr(de2bi(I(1:num_FHT)-1,3)); 
27
28 
 %%%%%%%%%%%%%% Compute 6-Bit Patterns Corresponding to Indices of
29
FHT Inputs %%%%%%%%%%%%%%%
bit_index_000 = [tmp(:,1:k-1) zeros(num_FHT,3) tmp(:,k:3)];
30
 bit_index_100 = [tmp(:,1:k-1) ones(num_FHT,1) zeros(num_FHT,2)
31
tmp(:,k:3)];
bit_index_010 = [tmp(:,1:k-1) zeros(num_FHT,1) ones(num_FHT,1)
32
zeros(num_FHT,1) tmp(:,k:3)];
bit_index_110 = [tmp(:,1:k-1) ones(num_FHT,2) zeros(num_FHT,1)
33
tmp(:,k:3)];
bit_index_001 = [tmp(:,1:k-1) zeros(num_FHT,2) ones(num_FHT,1)
34
tmp(:,k:3)];
bit_index_101 = [tmp(:,1:k-1) ones(num_FHT,1) zeros(num_FHT,1)
35
ones(num_FHT,1) tmp(:,k:3)];
bit_index_011 = [tmp(:,1:k-1) zeros(num_FHT,1) ones(num_FHT,2)
36
tmp(:,k:3)];
bit_index_111 = [tmp(:,1:k-1) ones(num_FHT,3) tmp(:,k:3)];
37
38 
 %%%%%%%%%%%%%% Compute FHTs from Received Signal %%%%%%%%%%%%%%%%
39
 Z = sum(fht(reshape(y([bi2de(bit_index_000) bi2de(bit_index_100) 
40

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\projected_FHT_8_6111.m 
bi2de(bit_index_010) bi2de(bit_index_110) ...
40
bi2de(bit_index_001) bi2de(bit_index_101)
41
bi2de(bit_index_011) bi2de(bit_index_111)]'+1,i+1),8,num_FHT)).^2,2); 
42 
 %%%%%%%%%%%% Hard Decison %%%%%%%%%%%%%% 

43
 [max_corr,decoded_Walsh_index] = max(Z); 

44

 decoded_Walsh_bits(6*i+k:6*i+k+2,1) = 

45

de2bi(decoded_Walsh_index-1,3)'; 

46 
 end 
47
48  end 
49 
%%%%%%%%% Compute Walsh Indices for Decoded Walsh Codewords %%%%%%%%%%
50
decoded_Walsh_index = 
51 
bi2de(reshape(decoded_Walsh_bits,6,num_codewords)')+1; 
52 
bit_errors = sum(decoded_Walsh_bits~=bits)
53
codeword_errors = sum(decoded_Walsh_index~=Walsh_index) 
54
55 

Page: 2 

File: C:\Documents and Settings\Matt\Desktop\walsh\rom.v 
/***********************************************************************
1
******** 
* 
This file is owned and controlled by Xilinx and must be used
2
* 
solely for design, simulation, implementation and creation of
* 
3
* 
design files limited to Xilinx devices or technologies. Use
* 
4
* 
* 
with non-Xilinx devices or technologies is expressly prohibited
5
* 
* 
and immediately terminates your license. 

6
*

*  

7
*

* 
8
* 
* 
9
* 
* 
10
* 
* 
11
* 
* 
12
* 
* 
13
* 
* 
14
* 
* 
15
* 
* 
16
* 
* 
17
* 
* 
18
* 
* 
19
* 
* 
20
*

*  

21
*

* 
22
* 
* 
23
* 
* 
24
*

*  

25
*

* 
26
* 
* 
27
* 
************************************************************************ 
28
*******/ 

XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
SOLELY FOR USE IN DEVELOPING PROGRAMS AND SOLUTIONS FOR 
XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION
AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION
OR STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS
IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY 
WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF 
INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE.  


Xilinx products are not intended for use in life support
appliances, devices, or systems. Use in such applications are
expressly prohibited.


(c) Copyright 1995-2004 Xilinx, Inc.

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\rom.v 
29  // The synopsys directives "translate_off/translate_on" specified below
are 
30  // supported by XST, FPGA Compiler II, Mentor Graphics and Synplicity
synthesis
// tools. Ensure they are correct for your synthesis tool(s). 
31
32 
// You must compile the wrapper file rom.v when simulating
33
// the core, rom. When compiling the wrapper file, be sure to
34
// reference the XilinxCoreLib Verilog simulation library. For detailed
35
// instructions, please refer to the "CORE Generator Help". 
36
37 
`timescale 1ns/1ps 
38
39 
module rom(
40
addr,

41 
clk,

42 
dout);

43 
44

45

46
47
48
49 
50
51 
52
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 

input [5 : 0] addr;
input clk;
output [9 : 0] dout; 
// synopsys translate_off 
 BLKMEMSP_V6_1 #(

6,  // c_addr_width

"0",  // c_default_data

64, // c_depth

0,  // c_enable_rlocs

0,  // c_has_default_data

0,  // c_has_din

0,  // c_has_en

0,  // c_has_limit_data_pitch

0,  // c_has_nd

0,  // c_has_rdy

0,  // c_has_rfd

0,  // c_has_sinit

0,  // c_has_we

18, // c_limit_data_pitch 

"rom.mif",  // c_mem_init_file 

0,  // c_pipe_stages

0,  // c_reg_inputs

"0",  // c_sinit_value

10, // c_width

0,  // c_write_mode

"0",  // c_ybottom_addr

1,  // c_yclk_is_rising

1,  // c_yen_is_high

"hierarchy1", // c_yhierarchy 

0,  // c_ymake_bmm

"16kx1",  // c_yprimitive_type 

1,  // c_ysinit_is_high

"1024", // c_ytop_addr 

0,  // c_yuse_single_primitive 

1,  // c_ywe_is_high


Page: 2 

File: C:\Documents and Settings\Matt\Desktop\walsh\rom.v 
1)  // c_yydisable_warnings 

83 
inst (

84 
.ADDR(addr),

85

.CLK(clk),

86

.DOUT(dout),

87

.DIN(),

88 
.EN(), 

89 
.ND(), 

90 
.RFD(),

91 
.RDY(),

92 
.SINIT(),

93 
.WE());

94 
95

96

// synopsys translate_on

97
98 
99  // FPGA Express black box declaration
// synopsys attribute fpga_dont_touch "true"
100
// synthesis attribute fpga_dont_touch of rom is "true" 
101
102
// XST black box declaration
103
// box_type "black_box"
104
// synthesis attribute box_type of rom is "black_box" 
105
106 
107  endmodule

108


Page: 3 

File: C:\Documents and Settings\Matt\Desktop\walsh\shift_register.v 
`timescale 1ns / 1ps 
1
2
module shift_register(reset, clk, shift, sr_in, sr_out);
3
input reset, clk, shift;

4
parameter WIDTH = 10;

5
input [WIDTH-1:0] sr_in;

6
output [WIDTH-1:0] sr_out; 

7
8
 parameter SIZE = 64; 
9
10
wire [WIDTH-1:0] sr_out; 
11
12
reg [WIDTH-1:0] sr [SIZE-1:0]; 

13
integer i;

14
always @(posedge clk) begin 

15
if (reset) begin
16
for (i = 0; i < SIZE; i = i + 1) begin
17
sr[i] <= 100'b0;
18
end

19
end

20
if (shift && !reset) begin 

21
for (i = 1; i < SIZE; i = i + 1) begin
22
sr[SIZE - i] <= sr[SIZE - i - 1];
23
end 
24
//sr[SIZE - 1:1] <= sr[SIZE - 2:0];
25
sr[0] <= sr_in;
26
end

27
end

28
29
assign sr_out = sr[SIZE - 1];

30
endmodule

31

Page: 1 

File: C:\Documents and Settings\Matt\Desktop\walsh\noisetobits.py 
import math, string, sys
1
def de2bi(n):
2
'''convert denary integer n to binary string bStr'''
3
bStr = ''
4
 if n < 0:  raise ValueError, "must be a positive integer"
5
if n == 0: return '0'
6
 while n > 0:
7
 bStr = str(n % 2) + bStr

8
n = n >> 1

9
 return bStr

10
11
f = open(sys.argv[1], 'r')

12
lines = f.readlines()

13
14
for num in lines:

15
num = float(num.strip())

16
num = num * 511 / 50

17
num = math.ceil(num)

18
if num >= 0:

19
num = "0" + string.zfill(str(de2bi(int(num))), 9)
20
else: 
21
num = 511 + int(num)
22
num = "1" + string.zfill(str(de2bi(num)), 9)
23
print num + "," 
24
25

Page: 1 

