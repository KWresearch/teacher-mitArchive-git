Chapter 4 

Mathematical Data Types 

4.1  Sets 

We’ve  been  assuming  that  the  concepts  of  sets,  sequences,  and  functions  are  al­
ready familiar ones, and we’ve mentioned them repeatedly. Now we’ll do a quick 
review of the deﬁnitions. 
Informally,  a  set  is  a  bunch  of  objects, which  are  called  the  elements  of  the  set. 
The elements of a set can be just about anything: numbers, points in space, or even 
other sets.  The conventional way to write down a set is to list the elements inside 
curly-braces.  For example, here are some sets: 
A  =  {Alex, Tippy, Shells, Shadow}  dead pets 
B  =  {red, blue, yellow} 
primary colors 
C  =  {{a, b} , {a, c} , {b, c}} 
a set of sets 
This works ﬁne for small ﬁnite sets. Other sets might be deﬁned by indicating how 
to generate a list of them: 
D = {1, 2, 4, 8, 16, . . . } 
the powers of 2 
The  order  of  elements  is  not  signiﬁcant,  so  {x, y}  and  {y , x}  are  the  same  set 
written  two  different  ways.  Also,  any  object  is,  or  is  not,  an  element  of  a  given 
set  —there  is  no  notion  of  an  element  appearing  more  than  once  in  a  set.1  So 
writing {x, x} is just indicating the same thing twice, namely, that x is in the set.  In 
particular, {x, x} = {x}. 
The expression e ∈ S  asserts that e is an element of set S .  For example, 32 ∈ D 
and blue ∈ B , but Tailspin  �∈ A —yet. 
Sets  are  simple,  ﬂexible,  and  everywhere.  You’ll  ﬁnd  some  set  mentioned  in 
nearly every section of this text. 

1 It’s  not  hard  to  develop  a  notion  of  multisets  in  which  elements  can  occur  more  than  once,  but 
multisets are not ordinary sets. 

51 

52	

CHAPTER 4.  MATHEMATICAL DATA TYPES 

4.1.1  Some Popular Sets 
Mathematicians have devised special symbols to represent some common sets. 

symbol 
∅ 
N 
Z 
Q 
R 
C 

elements 
set	
none 
the empty set 
nonnegative integers  {0, 1, 2, 3, . . .}
{. . . , −3, −2, −1, 0, 1, 2, 3, . . .}
integers 
2 ,  − 5
√
3 ,  16,  etc. 
1
rational numbers 
π ,  e,  −9, 
√
2,  etc. 
real numbers 
2 − 2i,  etc. 
19
complex numbers 
i,  2  , 
A superscript “+” restricts a set  to  its positive elements;  for example, R+  denotes 
the set of positive real numbers.  Similarly, R−  denotes the set of negative reals. 

4.1.2  Comparing and Combining Sets 
The  expression  S  ⊆  T  indicates  that  set  S  is  a  subset  of  set  T ,  which means  that 
every element of S  is also an element of T  (it could be  that S  =  T ).  For example, 
N ⊆ Z and Q ⊆ R (every rational number is a real number), but C  �⊆ Z (not every 
complex number is an integer). 
As a memory trick, notice that the ⊆ points to the smaller set, just like a ≤ sign 
points  to  the smaller number.  Actually,  this connection goes a  little  further:  there 
is a symbol ⊂ analogous to <.  Thus, S  ⊂  T  means that S  is a subset of T , but the 
two are not equal.  So A ⊆ A, but A  �⊂ A, for every set A. 
There are several ways to combine sets.  Let’s deﬁne a couple of sets for use in 
examples: 

X  ::= {1, 2, 3}

Y  ::= {2, 3, 4}

•	 The union of sets X  and Y  (denoted X  ∪ Y ) contains all elements appearing 
in X  or Y  or both. Thus, X ∪ Y  = {1, 2, 3, 4}. 
•	 The  intersection  of  X  and  Y  (denoted  X  ∩  Y )  consists  of  all  elements  that 
appear in both X  and Y .  So X ∩ Y  = {2, 3}. 
•	 The  set  difference  of X  and  Y  (denoted X  −  Y )  consists  of  all  elements  that 
are in X , but not in Y . Therefore, X − Y  = {1} and Y  − X  = {4}. 

4.1.3  Complement of a Set 
Sometimes we are  focused on a particular domain, D .  Then  for any  subset, A,  of 
D , we deﬁne A to be the set of all elements of D not in A. That is, A ::= D − A. The 
set A is called the complement of A. 

4.1.  SETS 

53 

For  example,  when  the  domain  we’re  working  with  is  the  real  numbers,  the 
complement  of  the  positive  real  numbers  is  the  set  of  negative  real  numbers  to­
gether with zero. That is, 
R+  = R−  ∪ {0} . 
It can be helpful  to  rephrase properties of sets using complements.  For exam­
ple, two sets, A and B , are said to be disjoint iff they have no elements in common, 
that is, A ∩ B  = ∅.  This is the same as saying that A is a subset of the complement 
of B , that is, A ⊆ B . 

4.1.4  Power Set 
The set of all the subsets of a set, A, is called the power set, P (A), of A.  So B  ∈ P (A) 
iff B ⊆ A.  For example, the elements of P ({1, 2}) are ∅, {1} , {2} and {1, 2}. 
More  generally,  if  A  has  n  elements,  then  there  are  2n  sets  in  P (A).  For  this 
reason, some authors use the notation 2A  instead of P (A). 

4.1.5  Set Builder Notation 
An  important  use  of  predicates  is  in  set  builder  notation.  We’ll  often  want  to  talk 
about  sets  that cannot be described very well by  listing  the elements explicitly or 
by  taking unions,  intersections,  etc.,  of easily-described  sets.  Set builder notation 
often comes to the rescue. The idea is to deﬁne a set using a predicate; in particular, 
the set consists of all values that make the predicate true. Here are some examples 
of set builder notation: 
� 
� 
A ::= {n ∈ N  | n is a prime and n = 4k + 1 for some integer k} 
x ∈ R  | x 3  − 3x + 1 > 0  � 
B ::= � 
C  ::=  a + bi ∈ C  | a 2  + 2b2  ≤ 1 
The set A consists of all nonnegative integers n for which the predicate 
“n is a prime and n = 4k + 1 for some integer k” 
is true. Thus, the smallest elements of A are: 
5, 13, 17, 29, 37, 41, 53, 57, 61, 73, . . . . 

Trying to indicate the set A by listing these ﬁrst few elements wouldn’t work very 
well; even after ten terms,  the pattern  is not obvious!  Similarly,  the set B  consists 
of all real numbers x for which the predicate 
x 3  − 3x + 1 > 0 
is true.  In this case, an explicit description of the set B  in terms of intervals would 
require  solving  a  cubic  equation.  Finally,  set  C  consists  of  all  complex  numbers 
a + bi such that: 
a 2  + 2b2  ≤ 1 

54 

CHAPTER 4.  MATHEMATICAL DATA TYPES 

This is an oval-shaped region around the origin in the complex plane. 

4.1.6  Proving Set Equalities 
Two sets are deﬁned to be equal if they contain the same elements. That is, X  = Y 
means  that  z  ∈  X  if  and  only  if  z  ∈  Y ,  for  all  elements,  z .  (This  is  actually  the 
ﬁrst  of  the ZFC  axioms.)  So  set  equalities  can  be  formulated  and  proved  as  “iff ” 
theorems.  For example: 
Theorem 4.1.1 (Distributive Law for Sets).  Let A, B , and C  be sets. Then: 
A ∩ (B ∪ C ) = (A ∩ B ) ∪ (A ∩ C ) 
Proof.  The equality (4.1) is equivalent to the assertion that 
z  ∈ A ∩ (B ∪ C ) 
iff  z  ∈ (A ∩ B ) ∪ (A ∩ C ) 
for all z . Now we’ll prove (4.2) by a chain of iff ’s. 
First we need a rule for distributing a propositional AND  operation over an OR 
operation.  It’s easy to verify by truth-table that 
Lemma 4.1.2.  The propositional formula 
P  AND  (Q OR R) 

(4.1) 

(4.2) 

and 

(P  AND Q) OR  (P  AND R) 

are equivalent. 
Now we have 
z  ∈ A ∩ (B ∪ C ) 
iff  (z  ∈ A) AND  (z  ∈ B ∪ C ) 
iff  (z  ∈ A) AND  (z  ∈ B OR z  ∈ C ) 
iff  (z  ∈ A AND  z  ∈ B ) OR  (z  ∈ A AND  z  ∈ C ) 
iff  (z  ∈ A ∩ B ) OR  (z  ∈ A ∩ C ) 
iff  z  ∈ (A ∩ B ) ∪ (A ∩ C ) 

(def of ∩) 
(def of ∪) 
(Lemma 4.1.2) 
(def of ∩) 
(def of ∪) 

4.1.7  Problems 
Homework Problems 

Problem 4.1. 
Let A, B , and C  be sets. Prove that: 
A ∪ B ∪ C  = (A − B ) ∪ (B − C ) ∪ (C − A) ∪ (A ∩ B ∩ C ). 
Hint: P  OR Q OR R is equivalent to 
(P  AND Q) OR  (Q AND R) OR  (R AND P ) OR  (P  AND Q AND R). 

� 

(4.3) 

4.2.  SEQUENCES	

4.2  Sequences 

55 

Sets provide one way to group a collection of objects. Another way is in a sequence, 
which is a list of objects called terms or components.  Short sequences are commonly 
described  by  listing  the  elements  between  parentheses;  for  example,  (a, b, c)  is  a 
sequence with three terms. 
While both sets and  sequences perform a gathering  role,  there are several dif­
ferences. 

•	 The elements of a set are required to be distinct, but terms in a sequence can 
be the same.  Thus, (a, b, a) is a valid sequence of length three, but {a, b, a} is 
a set with two elements —not three. 

•	 The  terms  in a sequence have a speciﬁed order, but  the elements of a set do 
not.  For  example,  (a, b, c)  and  (a, c, b)  are  different  sequences,  but  {a, b, c}
and {a, c, b} are the same set. 
•	 Texts  differ  on  notation  for  the  empty  sequence;  we  use  λ  for  the  empty  se­
quence. 

The product operation is one link between sets and sequences. A product of sets, 
S1 × S2 × · · ·× Sn , is a new set consisting of all sequences where the ﬁrst component 
is drawn from S1 , the second from S2 , and so forth. For example, N×{a, b} is the set 
of all pairs whose ﬁrst element is a nonnegative integer and whose second element 
is an a or a b: 

N × {a, b} = {(0, a), (0, b), (1, a), (1, b), (2, a), (2, b), . . . } 
A product of n copies of a set S  is denoted S n .  For example, {0, 1} 3  is the set of all 
3-bit sequences: 
{0, 1} 3  = {(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1)} 

4.3  Functions 

A function assigns an element of one set, called the domain, to elements of another 
set, called the codomain. The notation 

f  : A

B→ 

indicates  that  f  is  a  function  with  domain,  A,  and  codomain,  B .  The  familiar 
notation “f (a) =  b” indicates that f  assigns the element b  ∈ B  to a.  Here b would 
be called the value of f  at argument a. 
Functions are often deﬁned by formulas as in: 

f1 (x) ::= 

1 
x2 

56 

CHAPTER 4.  MATHEMATICAL DATA TYPES 

where x is a real-valued variable, or 

where y and z  range over binary strings, or 

f2 (y , z ) ::= y10yz 

f3 (x, n) ::=  the pair (n, x) 

where n ranges over the nonnegative integers. 
A  function  with  a  ﬁnite  domain  could  be  speciﬁed  by  a  table  that  shows  the 
value  of  the  function  at  each  element  of  the  domain.  For  example,  a  function 
f4 (P , Q) where P  and Q are propositional variables is speciﬁed by: 

P  Q  f4 (P , Q) 
T  T 
T 
F 
T  F 
T 
F  T 
F  F 
T 

Notice that f4  could also have been described by a formula: 

f4 (P , Q) ::= [P  IM P L I E S Q]. 

A function might also be deﬁned by a procedure for computing its value at any 
element of its domain, or by some other kind of speciﬁcation.  For example, deﬁne 
f5 (y) to be the length of a left to right search of the bits in the binary string y until 
a 1 appears, so 

f5 (0010)  =  3, 
f5 (100)  =  1, 
f5 (0000) 
is  undeﬁned. 

Notice  that f5  does not assign a value  to any string of  just 0’s.  This  illustrates 
an important fact about functions:  they need not assign a value to every element in 
the domain.  In fact this came up in our ﬁrst example f1 (x) = 1/x2 , which does not 
assign a value to 0.  So in general, functions may be partial functions, meaning that 
there may be domain elements for which the function is not deﬁned.  If a function 
is deﬁned on every element of its domain, it is called a total function. 
It’s  often useful  to ﬁnd  the  set  of  values  a  function  takes when  applied  to  the 
→
elements in a set of arguments.  So if f  :  A
B , and S  is a subset of A, we deﬁne 
f (S ) to be the set of all the values that f  takes when it is applied to elements of S . 
That is, 
f (S ) ::= {b ∈ B  | f (s) = b for some s ∈ S } . 
For  example,  if  we  let  [r, s]  denote  the  interval  from  r  to  s  on  the  real  line,  then 
f1 ([1, 2]) = [1/4, 1]. 

4.4.  BINARY RELATIONS 

57 

For another example, let’s take the “search for a 1” function, f5 .  If we let X  be 
the  set  of  binary words which  start with  an  even  number  of  0’s  followed  by  a  1, 
then f5 (X ) would be the odd nonnegative integers. 
Applying f  to a set, S , of arguments is referred to as “applying f  pointwise to 
S ”, and the set f (S ) is referred to as the image of S under f .2  The set of values that 
arise from applying f  to all possible arguments is called the range of f . That is, 

range (f ) ::= f (domain (f )). 

Some authors refer to the codomain as the range of a function, but they shouldn’t. 
The distinction between the range and codomain will be important in Sections 4.7 
and 4.8 when we relate sizes of sets to properties of functions between them. 

4.3.1  Function Composition 
Doing things step by step is a universal idea. Taking a walk is a literal example, but 
so is cooking from a recipe, executing a computer program, evaluating a formula, 
and recovering from substance abuse. 
Abstractly,  taking  a  step  amounts  to  applying  a  function,  and  going  step  by 
step corresponds to applying functions one after the other. This is captured by the 
operation  of  composing  functions.  Composing  the  functions  f  and  g  means  that 
ﬁrst  f  applied  is  to  some  argument,  x,  to  produce  f (x),  and  then  g  is  applied  to 
that result to produce g(f (x)). 

→ 
→
B  and g  : B
Deﬁnition 4.3.1.  For functions f  : A
C , the composition, g
→ 
g with f  is deﬁned to be the function h  : A
C  deﬁned by the rule: 
◦ 
f )(x) = h(x) ::= g(f (x)),

(g

◦ 
f , of 

for all x ∈ A. 
Function  composition  is  familiar  as  a basic  concept  from  elementary  calculus, 
and it plays an equally basic role in discrete mathematics. 

4.4  Binary Relations 

Relations  are  another  fundamental  mathematical  data  type.  Equality  and  “less­
than” are very familiar examples of mathematical relations. These are called binary 
relations because they apply to a pair (a, b) of objects; the equality relation holds for 
the pair when a = b, and less-than holds when a and b are real numbers and a < b. 
In  this  chapter  we’ll  deﬁne  some  basic  vocabulary  and  properties  of  binary 
relations. 
2 There is a picky distinction between the function f  which applies to elements of A and the function 
which applies f  pointwise to subsets of A, because the domain of f  is A, while the domain of pointwise­
f  is P (A).  It  is  usually  clear  from  context whether  f  or  pointwise-f  is meant,  so  there  is  no  harm  in 
overloading the symbol f  in this way. 

58 

CHAPTER 4.  MATHEMATICAL DATA TYPES 

4.5  Binary Relations and Functions 

Binary relations are far more general than equality or less-than.  Here’s the ofﬁcial 
deﬁnition: 

Deﬁnition 4.5.1.  A binary relation, R, consists of a set, A, called the domain of R, a 
set, B , called the codomain of R, and a subset of A × B  called the graph of R. 
Notice  that Deﬁnition  4.5.1  is  exactly  the  same  as  the  deﬁnition  in  Section  4.3 
of  a  function,  except  that  it  doesn’t  require  the  functional  condition  that,  for  each 
domain element, a,  there is at most one pair in the graph whose ﬁrst coordinate is 
a.  So a function is a special case of a binary relation. 
A relation whose domain is A and codomain is B  is said to be “between A and 
B ”,  or  “from A  to B .”  When  the  domain  and  codomain  are  the  same  set,  A,  we 
simply  say  the  relation  is  “on  A.”  It’s  common  to  use  inﬁx  notation  “a R b”  to 
mean that the pair (a, b) is in the graph of R. 
For example, we can deﬁne an “in-charge of ” relation, T , for MIT in Spring ’10 
to have domain equal to the set, F , of names of the faculty and codomain equal to 
all the set, N , of subject numbers in the current catalogue. The graph of T  contains 
precisely the pairs of the form 
(�instructor-name� , �subject-num�) 
such  that  the  faculty member named �instructor-name�  is  in charge of  the subject 
with number �subject-num� in Spring ’10.  So graph (T ) contains pairs like 

(A.  R.  Meyer,  6.042), 
(A.  R.  Meyer,  18.062), 
(A.  R.  Meyer,  6.844), 
(T.  Leighton,  6.042), 
(T.  Leighton,  18.062), 
(G,  Freeman, 
6.011), 
6.UAT), 
(G,  Freeman, 
6.881) 
(G.  Freeman, 
6.882) 
(G.  Freeman, 
(T.  Eng, 
6.UAT) 
(J.  Guttag, 
6.00) 
. . . 
This is a surprisingly complicated relation: Meyer is in charge of subjects with 
three numbers. Leighton is also in charge of subjects with two of these three num­
bers —because the same subject, Mathematics for Computer Science, has two num­
bers:  6.042  and  18.062,  and  Meyer  and  Leighton  are  co-in-charge  of  the  subject. 
Freeman is in-charge of even more subjects numbers (around 20), since as Depart­
ment Education Ofﬁcer, he is in charge of whole blocks of special subject numbers. 
Some  subjects,  like  6.844  and  6.00  have  only  one person  in-charge.  Some  faculty, 

4.6.  IMAGES AND INVERSE IMAGES 

59 

like  Guttag,  are  in  charge  of  only  one  subject  number,  and  no  one  else  is  co-in­
charge of his subject, 6.00. 
Some subjects  in  the codomain, N , do not appear  in  the  list —that  is,  they are 
not  an  element  of  any  of  the pairs  in  the  graph  of  T ;  these  are  the  Fall  term  only 
subjects.  Similarly,  there  are  faculty  in  the  domain,  F ,  who  do  not  appear  in  the 
list because all their in-charge subjects are Fall term only. 

4.6  Images and Inverse Images 

The faculty in charge of 6.UAT in Spring ’10 can be found by taking the pairs of the 
form 
(�instructor-name� , 6.U AT ) 
in the graph of the teaching relation, T , and then  just listing the left hand sides of 
these pairs; these turn out to be just Eng and Freeman. 
The  introductory  course  6  subjects  have  numbers  that  start  with  6.0 .  So  we 
can likewise ﬁnd out all the instructors in-charge of introductory course 6 subjects 
this  term,  by  taking  all  the  pairs  of  the  form  (�instructor-name� , 6.0 . . . )  and  list 
the  left  hand  sides  of  these  pairs.  For  example,  from  the  part  of  the  graph  of  T 
shown above, we can see that Meyer, Leighton, Freeman, and Guttag are in-charge 
of introductory subjects this term. 
These  are  all  examples  of  taking  an  inverse  image  of  a  set  under  a  relation.  If 
R  is  a  binary  relation  from A  to B ,  and X  is  any  set,  deﬁne  the  inverse  image  of 
X  under R,  written  simply  as  RX  to  be  the  set  elements  of A  that  are  related  to 
something in X . 
For  example,  let  D  be  the  set  of  introductory  course  6  subject  numbers.  So 
T D ,  the  inverse  image  of  the  set D  under  the  relation,  T ,  is  the  set  of  all  faculty 
members  in-charge of  introductory course 6  subjects  in Spring  ’10.  Notice  that  in 
inverse image notation, D gets written to the right of T  because, to ﬁnd the faculty 
members in T D , we’re looking pairs in the graph of T  whose right hand sides are 
subject numbers in D . 
Here’s a concise deﬁnition of the inverse image of a set X  under a relation, R: 
RX  ::= {a ∈ A  | aRx for some x ∈ X } . 
Similarly, the image of a set Y  under R, written Y R, is the set of elements of the 
codomain, B , that are related to some element in Y , namely, 
Y R ::= {b ∈ B  | yRb for some y ∈ Y } . 
So, {A. Meyer} T  gives the subject numbers that Meyer is in charge of in Spring 
’09.  In  fact, {A. Meyer} T  =  {6.042, 18.062, 6.844}.  Since  the domain, F ,  is  the set 
of all in-charge faculty, F T  is exactly the set of all Spring ’09 subjects being taught. 
Similarly, T N  is the set of people in-charge of a Spring ’09 subject. 
It gets interesting when we write composite expressions mixing images, inverse 
images  and  set  operations.  For  example,  (T D)T  is  the  set  of  Spring  ’09  subjects 

60	

CHAPTER 4.  MATHEMATICAL DATA TYPES 

that  have  people  in-charge  who  also  are  in-charge  of  introductory  subjects.  So 
(T D)T −D are the advanced subjects with someone in-charge who is also in-charge 
of an introductory subject.  Similarly, T D ∩ T (N  − D) is the set of faculty teaching 
both an introductory and an advanced subject in Spring ’09. 
Warning:  When R happens  to be a  function,  the pointwise application, R(Y ), 
of R to a set Y  described in Section 4.3 is exactly the same as the image of Y  under 
R.  That means  that when R  is  a  function, R(Y ) =  Y R —not RY .  Both notations 
are common in math texts, so you’ll have to live with the fact that they clash. Sorry 
about that. 

4.7  Surjective and Injective Relations 

There are a few properties of relations that will be useful when we take up the topic 
of counting because they imply certain relations between the sizes of domains and 
→ 
codomains. We say a binary relation R  : A
B  is:

•	 total when  every  element of A  is  assigned  to  some  element of B ; more  con­
cisely, R is total iff A = RB . 

•	 surjective when every element of B is mapped to at least once3 ; more concisely, 
R is surjective iff AR = B . 

•	 injective if every element of B  is mapped to at most once, and 

•	 bijective if R is total, surjective, and injective function. 

Note that this deﬁnition of R being total agrees with the deﬁnition in Section 4.3 
when R is a function. 
If R  is a binary relation  from A  to B , we deﬁne AR  to  to be  the range of R.  So 
a  relation  is  surjective  iff  its  range  equals  its  codomain.  Again,  in  the  case  that R 
is a function, these deﬁnitions of “range” and “total” agree with the deﬁnitions in 
Section 4.3. 

4.7.1  Relation Diagrams 
→
We can explain all these properties of a relation R  :  A
B  in terms of a diagram 
where all the elements of the domain, A, appear in one column (a very long one if 
A  is  inﬁnite) and all  the elements of  the codomain, B ,  appear  in another column, 
and we  draw  an  arrow  from  a  point  a  in  the  ﬁrst  column  to  a  point  b  in  the  sec­
ond  column when a  is  related  to  b by R.  For example,  here are diagrams  for  two 
functions: 

3  The names  “surjective”  and  “injective”  are unmemorable  and nondescriptive.  Some  authors use 
the term onto for surjective and one-to-one for injective, which are shorter but arguably no more memo­
rable. 

4.8.  THE MAPPING RULE 

61 

A

b

a 

B	
�  1	
�������	�
2	
�	�
�
����
c 
�� 3
�	
���� �
d  �
� 
4	
�
�	
e  �

A

a 

B 
�  1 
������� �
2 
b
� �
� 
c  � �
��
d  �  �
�

3 

���

4 

5 

Here is what the deﬁnitions say about such pictures: 
•	 “R  is  a  function”  means  that  every  point  in  the  domain  column,  A,  has  at 
most one arrow out of it. 
•	 “R is total” means that every point in the A column has at least one arrow out of 
it.  So if R is a function, being total really means every point in the A column 
has exactly one arrow out of it. 
•	 “R  is  surjective” means  that  every  point  in  the  codomain  column,  B ,  has  at 
least one arrow into it. 
•	 “R  is  injective” means  that  every  point  in  the  codomain  column,  B ,  has  at 
most one arrow into it. 
•	 “R is bijective” means that every point in the A column has exactly one arrow 
out of it, and every point in the B  column has exactly one arrow into it. 
So  in  the diagrams above,  the  relation on  the  left  is a  total,  surjective  function 
(every  element  in  the A  column has  exactly  one  arrow  out,  and  every  element  in 
the B column has at least one arrow in), but not injective (element 3 has two arrows 
going into it).  The relation on the right is a total, injective function (every element 
in the A column has exactly one arrow out, and every element in the B column has 
at most one arrow in), but not surjective (element 4 has no arrow going into it). 
Notice  that  the arrows  in a diagram  for R precisely correspond  to  the pairs  in 
the  graph  of R.  But  graph (R)  does  not  determine  by  itself whether R  is  total  or 
surjective; we also need to know what the domain is to determine if R is total, and 
we need to know the codomain to tell if it’s surjective. 
Example  4.7.1.  The  function  deﬁned  by  the  formula  1/x2  is  total  if  its  domain  is 
R+  but partial if its domain is some set of real numbers including 0.  It is bijective 
if  its domain  and  codomain  are both R+ ,  but neither  injective nor  surjective  if  its 
domain and codomain are both R. 

4.8  The Mapping Rule 

The  relational properties  above  are useful  in ﬁguring out  the  relative  sizes of do­
mains and codomains. 

62 

CHAPTER 4.  MATHEMATICAL DATA TYPES 

If A  is a ﬁnite set, we  let  |A| be  the number of elements  in A.  A ﬁnite set may 
have no elements (the empty set), or one element, or two elements,. . . or any non­
negative integer number of elements. 
→
Now  suppose R  :  A
B  is  a  function.  Then  every  arrow  in  the diagram  for 
R  comes  from  exactly  one  element  of  A,  so  the  number  of  arrows  is  at most  the 
number of elements in A. That is, if R is a function, then 
|A| ≥ #arrows. 

Similarly,  if R  is surjective,  then every element of B  has an arrow  into  it,  so  there 
must be at least as many arrows in the diagram as the size of B . That is, 
#arrows ≥ |B | . 
Combining  these  inequalities  implies  that  if R  is a  surjective  function,  then  |A| ≥ 
|B |.  In short,  if we write A  surj  B  to mean that there  is a surjective function from 
A to B , then we’ve just proved a lemma:  if A surj B , then |A| ≥ |B |. The following 
deﬁnition  and  lemma  lists  include  this  statement  and  three  similar  rules  relating 
domain and codomain size to relational properties. 

Deﬁnition 4.8.1.  Let A, B be (not necessarily ﬁnite) sets. Then 

1.  A surj B  iff there is a surjective function from A to B . 

2.  A inj B  iff there is a total injective relation from A to B . 

3.  A bij B  iff there is a bijection from A to B . 

4.  A strict B  iff A surj B , but not B  surj A. 

Lemma 4.8.2.  [Mapping Rules]  Let A and B  be ﬁnite sets. 
1.  If A surj B , then |A| ≥ |B |. 
2.  If A  inj B , then |A| ≤ |B |. 
3.  If R bij B , then |A| = |B |. 
4.  If R strict B , then |A| > |B |. 

Mapping  rule  2  can  be  explained  by  the  same  kind  of  “arrow  reasoning”  we 
used  for  rule  1.  Rules  3  and  4  are  immediate  consequences  of  these  ﬁrst  two 
mapping rules. 

4.9  The sizes of inﬁnite sets 

Mapping Rule 1 has a converse:  if the size of a ﬁnite set, A, is greater than or equal 
to  the  size  of  another  ﬁnite  set,  B ,  then  it’s  always  possible  to deﬁne  a  surjective 

4.9.  THE SIZES OF INFINITE SETS 

63 

function from A to B .  In fact, the surjection can be a total function. To see how this 
works, suppose for example that 
A = {a0 , a1 , a2 , a3 , a4 , a5}
B = {b0 , b1 , b2 , b3} . 
→ 
Then deﬁne a total function f  : A

B by the rules 

f (a0 ) ::= b0 , f (a1 ) ::= b1 , f (a2 ) ::= b2 , f (a3 ) = f (a4 ) = f (a5 ) ::= b3 . 

In  fact,  if A and B  are ﬁnite  sets of  the  same  size,  then we  could also deﬁne a 
bijection from A to B by this method. 
In short, we have ﬁgured out if A and B are ﬁnite sets, then |A| ≥ |B | if and only 
if  A surj B , and similar iff ’s hold for all the other Mapping Rules: 

Lemma 4.9.1.  For ﬁnite sets, A, B , 
|A| ≥ |B | 
|A| ≤ |B | 
|A| = |B | 
|A| > |B | 

iff  A surj B , 
iff  A  inj B , 
iff  A bij B , 
iff  A strict B . 

This  lemma  suggests  a  way  to  generalize  size  comparisons  to  inﬁnite  sets, 
namely, we can  think of  the relation surj as an “at  least as big as” relation between 
sets, even if they are inﬁnite.  Similarly, the relation bij can be regarded as a “same 
size”  relation  between  (possibly  inﬁnite)  sets,  and  strict  can  be  thought  of  as  a 
“strictly bigger than” relation between sets. 
Warning:  We haven’t,  and won’t, deﬁne what  the “size” of an  inﬁnite  is.  The 
deﬁnition of  inﬁnite “sizes”  is cumbersome and  technical,  and we can get by  just 
ﬁne without it.  All we need are the “as big as” and “same size” relations, surj and 
bij, between sets. 
But  there’s  something  else  to  watch  out  for.  We’ve  referred  to  surj  as  an  “as 
big as” relation and bij as a “same size” relation on sets. Of course most of the “as 
big  as”  and  “same  size”  properties  of  surj  and  bij  on  ﬁnite  sets  do  carry  over  to 
inﬁnite sets, but some important ones don’t —as we’re about to show.  So you have to 
be careful: don’t assume that surj has any particular “as big as” property on inﬁnite 
sets until it’s been proved. 
Let’s  begin  with  some  familiar  properties  of  the  “as  big  as”  and  “same  size” 
relations on ﬁnite sets that do carry over exactly to inﬁnite sets: 

Lemma 4.9.2.  For any sets, A, B , C , 

1.  A surj B  and B  surj C, 

implies  A surj C . 

2.  A bij B  and B  bij C, 

implies  A bij C . 

3.  A bij B 

implies  B  bij A. 

64 

CHAPTER 4.  MATHEMATICAL DATA TYPES 

Lemma 4.9.2.1 and 4.9.2.2  follow  immediately  from  the  fact  that compositions 
of  surjections  are  surjections,  and  likewise  for  bijections,  and  Lemma  4.9.2.3  fol­
lows  from  the  fact  that  the  inverse of a bijection  is a bijection.  We’ll  leave a proof 
of these facts to Problem 4.2. 
Another familiar property of ﬁnite sets carries over to inﬁnite sets, but this time 
it’s not so obvious: 
Theorem  4.9.3  (Schr ¨oder-Bernstein).  For  any  sets  A, B ,  if  A  surj  B  and  B  surj  A, 
then A bij B . 
That  is,  the  Schr ¨oder-Bernstein  Theorem  says  that  if  A  is  at  least  as  big  as  B 
and  conversely,  B  is  at  least  as  big  as  A,  then  A  is  the  same  size  as  B .  Phrased 
this way,  you might be  tempted  to  take  this  theorem  for  granted,  but  that would 
be a mistake. For inﬁnite sets A and B , the Schr ¨oder-Bernstein Theorem is actually 
→
pretty  technical.  Just  because  there  is  a  surjective  function  f  :  A
B  —which
→
need not be  a bijection —and  a  surjective  function  g  :  B
A —which  also need 
→
not be a bijection —it’s not at all clear that there must be a bijection e : A
B . The 
idea is to construct e from parts of both f  and g . We’ll leave the actual construction 
to Problem 4.7. 

Inﬁnity is different 

A basic property of ﬁnite sets that does not carry over to inﬁnite sets is that adding 
something  new  makes  a  set  bigger.  That  is,  if  A  is  a  ﬁnite  set  and  b  ∈/ A,  then 
|A ∪ {b}| =  |A| + 1, and so A and A ∪ {b} are not the same size. But if A is inﬁnite, 
then these two sets are the same size! 
Lemma 4.9.4.  Let A be a set and b /∈ A. Then A is inﬁnite iff A bij A ∪ {b}. 
Proof.  Since A is not the same size as A ∪ {b} when A is ﬁnite, we only have to show 
that A ∪ {b} is the same size as A when A is inﬁnite. 
That  is, we have  to ﬁnd a bijection between A ∪ {b} and A when A  is  inﬁnite. 
Here’s how:  since A  is  inﬁnite,  it certainly has at  least one element;  call  it a0 .  But 
since A is inﬁnite, it has at least two elements, and one of them must not be equal 
to a0 ; call this new element a1 . But since A is inﬁnite, it has at least three elements, 
one of which must not equal a0  or a1 ; call this new element a2 .  Continuing in the 
way, we conclude that there is an inﬁnite sequence a0 , a1 , a2 , . . . , an , . . .  of different 
elements of A. Now it’s easy to deﬁne a bijection e : A ∪ {b} → A: 
e(b) ::= a0 , 
e(an ) ::= an+1 
e(a) ::= a 

for n ∈ N, 
for a ∈ A − {b, a0 , a1 , . . . } . 

� 
A  set,  C ,  is  countable  iff  its  elements  can  be  listed  in  order,  that  is,  the distinct 
elements is A are precisely 

c0 , c1 , . . . , cn , . . . . 

4.9.  THE SIZES OF INFINITE SETS 

65 

This means that if we deﬁned a function, f , on the nonnegative integers by the rule 
that f (i) ::= ci , then f  would be a bijection from N to C . More formally, 
Deﬁnition 4.9.5.  A set, C ,  is countably  inﬁnite  iff N  bij  C .  A set  is countable  iff  it  is 
ﬁnite or countably inﬁnite. 

A small modiﬁcation4  of the proof of Lemma 4.9.4 shows that countably inﬁnite 
sets  are  the  “smallest”  inﬁnite  sets,  namely,  if  A  is  a  countably  inﬁnite  set,  then 
A surj N. 
Since  adding  one  new  element  to  an  inﬁnite  set  doesn’t  change  its  size,  it’s 
obvious  that  neither  will  adding  any  ﬁnite  number  of  elements.  It’s  a  common 
mistake  to  think  that  this proves  that you can  throw  in countably  inﬁnitely many 
new elements.  But just because it’s ok to do something any ﬁnite number of times 
doesn’t make it OK to do an inﬁnite number of times.  For example, starting from 
3,  you  can  add  1  any  ﬁnite  number  of  times  and  the  result  will  be  some  integer 
greater  than  or  equal  to  3.  But  if  you  add  add  1  a  countably  inﬁnite  number  of 
times, you don’t get an integer at all. 
It  turns  out  you  really  can  add  a  countably  inﬁnite  number  of  new  elements 
to a countable set and still wind up with  just a countably  inﬁnite set, but another 
argument is needed to prove this: 
Lemma 4.9.6.  If A and B  are countable sets, then so is A ∪ B . 
Proof.  Suppose  the  list  of  distinct  elements  of  A  is  a0 , a1 , . . .  and  the  list  of  B  is 
b0 , b1 , . . . . Then a list of all the elements in A ∪ B  is just 

a0 , b0 , a1 , b1 , . . . an , bn , . . . . 

(4.4) 

Of  course  this  list will  contain  duplicates  if  A  and  B  have  elements  in  common, 
but  then deleting all but  the ﬁrst occurrences of each element  in  list  (4.4)  leaves a 
� 
list of all the distinct elements of A and B . 

4.9.1  Inﬁnities in Computer Science 
We’ve  run  into  a  lot  of  computer  science  students who wonder why  they  should 
care about  inﬁnite sets:  any data set  in a computer memory  is  limited by  the size 
of memory,  and  since  the  universe  appears  to  have  ﬁnite  size,  there  is  a  limit  on 
the possible size of computer memory. 
The problem with this argument is that universe-size bounds on data items are 
so big and uncertain (the universe seems to be getting bigger all the time), that it’s 
simply not helpful to make use of possible bounds. For example, by this argument 
the  physical  sciences  shouldn’t  assume  that measurements might  yield  arbitrary 
real numbers, because there can only be a ﬁnite number of ﬁnite measurements in 
a universe of ﬁnite lifetime.  What do you think scientiﬁc theories would look like 
without using the inﬁnite set of real numbers? 

4 See Problem 4.3 

66 

CHAPTER 4.  MATHEMATICAL DATA TYPES 

Similary,  in computer  science,  it  simply  isn’t plausible  that writing a program 
to add nonnegative integers with up to as many digits as, say,  the stars in the sky 
(billions of galaxies each with billions of stars), would be any different than writing 
a program that would add any two integers no matter how many digits they had. 
That’s why basic programming data types like integers or strings, for example, 
can be deﬁned without imposing any bound on the sizes of data items. Each datum 
of type string has only a ﬁnite number of letters, but there are an inﬁnite number 
of data  items  of  type string.  When we  then  consider  string procedures  of  type 
string-->string, not only are there an inﬁnite number of such procedures, but 
each  procedure  generally  behaves differently  on different  inputs,  so  that  a  single 
string-->string procedure may embody an inﬁnite number of behaviors. 
In short, an educated computer scientist can’t get around having to understand 
inﬁnite sets. 

4.9.2  Problems 

Class Problems 

Problem 4.2. 
Deﬁne a surjection relation, surj, on sets by the rule 

Deﬁnition.  A surj B  iff there is a surjective function from A to B . 

Deﬁne the injection relation, inj, on sets by the rule 

Deﬁnition.  A  inj B  iff there is a total injective relation from A to B . 

(a)  Prove that if A surj B  and B  surj C , then A surj C . 

(b)  Explain why A surj B  iff B  inj A. 

(c)  Conclude from (a) and (b) that if A  inj B  and B  inj C , then A  inj C . 

Problem 4.3. 

4.9.  THE SIZES OF INFINITE SETS 

67 

Lemma 4.9.4. Let A be a set and b /∈ A.  If A is inﬁnite, then there is a bijection from 
A ∪ {b} to A. 

Proof.  Here’s how to deﬁne the bijection:  since A is inﬁnite, it certainly has at least 
one element; call it a0 .  But since A is inﬁnite, it has at least two elements, and one 
of  them must not be  equal  to a0 ;  call  this new  element a1 .  But  since A  is  inﬁnite, 
it has  at  least  three  elements,  one of which must not  equal  a0  or  a1 ;  call  this new 
element a2 .  Continuing in the way, we conclude that there is an inﬁnite sequence 
a0 , a1 , a2 , . . . , an , . . .  of  different  elements  of  A.  Now  we  can  deﬁne  a  bijection 
f  : A ∪ {b} → A: 
f (b) ::= a0 , 
f (an ) ::= an+1 
f (a) ::= a 

for n ∈ N, 
for a ∈ A − {b, a0 , a1 , . . . } . 

� 

(a)  Several students felt the proof of Lemma 4.9.4 was worrisome, if not circular. 
What do you think? 

(b)  Use the proof of Lemma 4.9.4 to show that if A is an inﬁnite set, then there is 
surjective  function  from A  to N,  that  is,  every  inﬁnite  set  is  “as  big  as”  the  set  of 
nonnegative integers. 

Problem 4.4. 
→
Let R  : A
B  be a binary relation.  Use an arrow counting argument to prove the 
following generalization of the Mapping Rule: 
Lemma.  If R is a function, and X  ⊆ A, then 
|X | ≥ |X R| . 

Problem 4.5. 
Let  A  =  {a0 , a1 , . . . , an−1 }  be  a  set  of  size  n,  and  B  =  {b0 , b1 , . . . , bm−1}  a  set  of 
size m.  Prove that |A × B | = mn by deﬁning a simple bijection from A × B  to the 
nonnegative integers from 0 to mn − 1. 

Problem 4.6. 
The rational numbers ﬁll in all the spaces between the integers, so a ﬁrst thought is 
that there must be more of them than the integers, but it’s not true.  In this problem 

68 

CHAPTER 4.  MATHEMATICAL DATA TYPES 

you’ll show that there are the same number of nonnegative rational as nonnegative 
integers.  In short, the nonnegative rationals are countable. 
(a)  Describe a bijection between all the integers, Z, and the nonnegative integers, 
N. 
(b)  Deﬁne a bijection between the nonnegative integers and the set, N × N, of all 
the ordered pairs of nonnegative integers: 

(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), . . . 
(1, 0), (1, 1), (1, 2), (1, 3), (1, 4), . . . 
(2, 0), (2, 1), (2, 2), (2, 3), (2, 4), . . . 
(3.0), (3, 1), (3, 2), (3, 3), (3, 4), . . . 
. . . 

(c)  Conclude  that  N  is  the  same  size  as  the  set,  Q,  of  all  nonnegative  rational 
numbers. 

Problem 4.7. 
Suppose sets A and B have no elements in common, and 

•  B  is as small as A because there is a total injective function g  : B

•  A is as small as B because there is a total injective function f  : A

→ 
B , and 
A.→ 
Picturing  the  diagrams  for  f  and  g ,  there  is  exactly  one  arrow  out  of  each  ele­
ment —a left-to-right f -arrow if the element in A and a right-to-left g -arrow if the 
element in B .  This is because f  and g  are total functions.  Also, there is at most one 
arrow into any element, because f  and g are injections. 
So starting at any element, there is a unique, and unending path of arrows go­
ing forwards. There is also a unique path of arrows going backwards, which might 
be unending, or might end at an element that has no arrow into it. These paths are 
completely separate:  if two ran into each other, there would be two arrows into the 
element where they ran together. 
This divides all the elements into separate paths of four kinds: 

i.  paths that are inﬁnite in both directions, 

ii.  paths that are inﬁnite going forwards starting from some element of A. 

iii.  paths that are inﬁnite going forwards starting from some element of B . 

iv.  paths that are unending but ﬁnite. 

(a)  What do the paths of the last type (iv) look like? 

(b)  Show that for each type of path, either 

4.9.  THE SIZES OF INFINITE SETS 

69 

•  the f -arrows deﬁne a bijection between the A and B  elements on the path, or 
•  the g -arrows deﬁne a bijection between B  and A elements on the path, or 
•  both sets of arrows deﬁne bijections. 

For which kinds of paths do both sets of arrows deﬁne bijections? 

(c)  Explain how  to piece  these bijections  together  to prove  that A  and B  are  the 
same size. 

Homework Problems 

Problem 4.8. 
→ 
→
C  be  functions and h  :  A
Let f  :  A
B  and g  :  B
namely, h(a) ::= g(f (a)) for all a ∈ A. 
(a)  Prove that if f  and g are surjections, then so is h. 

→

C  be  their composition, 

(b)  Prove that if f  and g are bijections, then so is h. 
→ 
(c)  If f  is a bijection, then deﬁne f �  : B
A so that 
f � (b) ::=  the unique a ∈ A such that f (a) = b. 
Prove that f �  is a bijection.  (The function f �  is called the inverse of f .  The notation 
f −1  is often used for the inverse of f .) 

Problem 4.9. 
In  this problem  you will prove  a  fact  that may  surprise  you —or make  you  even 
more convinced that set theory is nonsense:  the half-open unit interval is actually 
the  same  size  as  the  nonnegative  quadrant  of  the  real  plane!5  Namely,  there  is  a 
bijection from (0, 1] to [0, ∞)2 . 
(a)  Describe a bijection from (0, 1] to [0, ∞). 
Hint:  1/x almost works. 
(b)  An  inﬁnite  sequence  of  the  decimal  digits  {0, 1, . . . , 9}  will  be  called  long  if 
it  has  inﬁnitely many  occurrences  of  some  digit  other  than  0.  Let L  be  the  set  of 
all such  long sequences.  Describe a bijection  from L  to  the half-open real  interval 
(0, 1]. 
Hint: Put a decimal point at the beginning of the sequence. 

(c)  Describe  a  surjective  function  from  L  to  L2  that  involves  alternating  digits 
from two long sequences.  a Hint: The surjection need not be total. 

(d)  Prove the following lemma and use it to conclude that there is a bijection from 
L2  to (0, 1]2 . 
5 The half open unit interval, (0, 1], is {r  ∈ R  | 0 < r ≤ 1}.  Similarly, [0, ∞) ::= {r  ∈ R  | r ≥ 0}. 

70 

CHAPTER 4.  MATHEMATICAL DATA TYPES 

Lemma  4.9.7.  Let A  and B  be  nonempty  sets.  If  there  is  a  bijection  from A  to B ,  then 
there is also a bijection from A × A to B × B . 
(e)  Conclude  from  the  previous  parts  that  there  is  a  surjection  from  (0, 1]  and 
(0, 1]2 .  Then appeal to the Schr ¨oder-Bernstein Theorem to show that there is actu­
ally a bijection from (0, 1] and (0, 1]2 . 
(f)  Complete the proof that there is a bijection from (0, 1] to [0, ∞)2 . 

4.10.  GLOSSARY OF SYMBOLS 

71 

4.10  Glossary of Symbols 

symbol  meaning 
∈ 
is a member of 
⊆ 
is a subset of 
⊂ 
is a proper subset of 
∪ 
set union 
∩
set intersection 
complement of a set, A 
A 
P (A) 
powerset of a set, A 
the empty set, {}
∅ 
N 
nonnegative integers 
Z 
integers 
Z+ 
positive integers 
Z− 
negative integers 
Q 
rational numbers 
R 
real numbers 
C 
complex numbers 
the empty string/list 
λ 

72 

CHAPTER 4.  MATHEMATICAL DATA TYPES 

MIT OpenCourseWare
http://ocw.mit.edu 

6.042J / 18.062J Mathematics for Computer Science 
Spring 2010 

For information about citing these materials or our Terms of Use, visit: http://ocw.mit.edu/terms . 

